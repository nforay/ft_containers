<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ft_container: ft::list&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ft_container<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ft</b></li><li class="navelem"><a class="el" href="classft_1_1list.html">list</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classft_1_1list-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ft::list&lt; T, Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions.  
 <a href="classft_1_1list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="list_8hpp_source.html">list.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a99e181e032dab80959b7f46f3f90849e"><td class="memItemLeft" align="right" valign="top"><a id="a99e181e032dab80959b7f46f3f90849e" name="a99e181e032dab80959b7f46f3f90849e"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a99e181e032dab80959b7f46f3f90849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280afb43b6249e9006d59bf35aa04406"><td class="memItemLeft" align="right" valign="top"><a id="a280afb43b6249e9006d59bf35aa04406" name="a280afb43b6249e9006d59bf35aa04406"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a280afb43b6249e9006d59bf35aa04406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad269defe34c59fe7c6c76ec4f503a631"><td class="memItemLeft" align="right" valign="top"><a id="ad269defe34c59fe7c6c76ec4f503a631" name="ad269defe34c59fe7c6c76ec4f503a631"></a>
typedef Alloc::template rebind&lt; Node &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><b>Node_allocator</b></td></tr>
<tr class="separator:ad269defe34c59fe7c6c76ec4f503a631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6804d1b93501feae8f4151040aa81093"><td class="memItemLeft" align="right" valign="top"><a id="a6804d1b93501feae8f4151040aa81093" name="a6804d1b93501feae8f4151040aa81093"></a>
typedef allocator_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a6804d1b93501feae8f4151040aa81093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4587bc2ea77fc2d4162b14fe00f8ebb5"><td class="memItemLeft" align="right" valign="top"><a id="a4587bc2ea77fc2d4162b14fe00f8ebb5" name="a4587bc2ea77fc2d4162b14fe00f8ebb5"></a>
typedef allocator_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a4587bc2ea77fc2d4162b14fe00f8ebb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d6ade1197f8615e8284e7ff389c83d"><td class="memItemLeft" align="right" valign="top"><a id="a11d6ade1197f8615e8284e7ff389c83d" name="a11d6ade1197f8615e8284e7ff389c83d"></a>
typedef allocator_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a11d6ade1197f8615e8284e7ff389c83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6ad4d0029f96ab0724214bc2efdae9"><td class="memItemLeft" align="right" valign="top"><a id="aba6ad4d0029f96ab0724214bc2efdae9" name="aba6ad4d0029f96ab0724214bc2efdae9"></a>
typedef allocator_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:aba6ad4d0029f96ab0724214bc2efdae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd33e362a3b9b8c5aad7e67785cb79da"><td class="memItemLeft" align="right" valign="top"><a id="acd33e362a3b9b8c5aad7e67785cb79da" name="acd33e362a3b9b8c5aad7e67785cb79da"></a>
typedef <a class="el" href="classft_1_1List__iterator.html">List_iterator</a>&lt; T, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:acd33e362a3b9b8c5aad7e67785cb79da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9517e5d156b0e448345c7b0f4afb7c2d"><td class="memItemLeft" align="right" valign="top"><a id="a9517e5d156b0e448345c7b0f4afb7c2d" name="a9517e5d156b0e448345c7b0f4afb7c2d"></a>
typedef <a class="el" href="classft_1_1List__const__iterator.html">List_const_iterator</a>&lt; T, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a9517e5d156b0e448345c7b0f4afb7c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee8f9c9b286490421f398925b34e23a"><td class="memItemLeft" align="right" valign="top"><a id="a4ee8f9c9b286490421f398925b34e23a" name="a4ee8f9c9b286490421f398925b34e23a"></a>
typedef <a class="el" href="classft_1_1List__const__reverse__iterator.html">List_const_reverse_iterator</a>&lt; T, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a4ee8f9c9b286490421f398925b34e23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c127315df316eae281bf414cf54b14"><td class="memItemLeft" align="right" valign="top"><a id="a47c127315df316eae281bf414cf54b14" name="a47c127315df316eae281bf414cf54b14"></a>
typedef <a class="el" href="classft_1_1List__reverse__iterator.html">List_reverse_iterator</a>&lt; T, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a47c127315df316eae281bf414cf54b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63fadcc2e4c234a83c7e386406d3904"><td class="memItemLeft" align="right" valign="top"><a id="ab63fadcc2e4c234a83c7e386406d3904" name="ab63fadcc2e4c234a83c7e386406d3904"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:ab63fadcc2e4c234a83c7e386406d3904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba605887cd6ae7112f67c2438da813e4"><td class="memItemLeft" align="right" valign="top"><a id="aba605887cd6ae7112f67c2438da813e4" name="aba605887cd6ae7112f67c2438da813e4"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:aba605887cd6ae7112f67c2438da813e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95e09f8039e5925a7907bd7772d3233c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a95e09f8039e5925a7907bd7772d3233c">list</a> (const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a95e09f8039e5925a7907bd7772d3233c"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty container constructor (default constructor): Constructs an empty container, with no elements.  <a href="classft_1_1list.html#a95e09f8039e5925a7907bd7772d3233c">More...</a><br /></td></tr>
<tr class="separator:a95e09f8039e5925a7907bd7772d3233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bddedad2cfb0ca84b9f4c78c5476759"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a1bddedad2cfb0ca84b9f4c78c5476759">list</a> (size_type n, const value_type &amp;val=value_type(), const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a1bddedad2cfb0ca84b9f4c78c5476759"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill constructor: Constructs a container with n elements. Each element is a copy of val.  <a href="classft_1_1list.html#a1bddedad2cfb0ca84b9f4c78c5476759">More...</a><br /></td></tr>
<tr class="separator:a1bddedad2cfb0ca84b9f4c78c5476759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b03765ecedff00ae5d405a6532b8fe"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a55b03765ecedff00ae5d405a6532b8fe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a55b03765ecedff00ae5d405a6532b8fe">list</a> (typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type first, InputIterator last, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a55b03765ecedff00ae5d405a6532b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">range constructor: Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range, in the same order. The range includes all the elements between first and last, including the element pointed by first but not the element pointed by last.  <a href="classft_1_1list.html#a55b03765ecedff00ae5d405a6532b8fe">More...</a><br /></td></tr>
<tr class="separator:a55b03765ecedff00ae5d405a6532b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ab3d40206836a01496828fcce5f4ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#af4ab3d40206836a01496828fcce5f4ca">list</a> (const <a class="el" href="classft_1_1list.html">list</a> &amp;x)</td></tr>
<tr class="memdesc:af4ab3d40206836a01496828fcce5f4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor: Constructs a container with a copy of each of the elements in x, in the same order.  <a href="classft_1_1list.html#af4ab3d40206836a01496828fcce5f4ca">More...</a><br /></td></tr>
<tr class="separator:af4ab3d40206836a01496828fcce5f4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b6e11a5748eceb2d67aedfe0b2104"><td class="memItemLeft" align="right" valign="top"><a id="a357b6e11a5748eceb2d67aedfe0b2104" name="a357b6e11a5748eceb2d67aedfe0b2104"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~list</b> ()</td></tr>
<tr class="memdesc:a357b6e11a5748eceb2d67aedfe0b2104"><td class="mdescLeft">&#160;</td><td class="mdescRight">List destructor: Destroys the container object. This destroys all container elements, and deallocates all the storage capacity allocated by the list container using its allocator. <br /></td></tr>
<tr class="separator:a357b6e11a5748eceb2d67aedfe0b2104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae68f02a55156cf783f8164cb5a4a1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1list.html">list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aae68f02a55156cf783f8164cb5a4a1cb">operator=</a> (const <a class="el" href="classft_1_1list.html">list</a> &amp;x)</td></tr>
<tr class="memdesc:aae68f02a55156cf783f8164cb5a4a1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. The container preserves its current allocator, which is used to allocate additional storage if needed.  <a href="classft_1_1list.html#aae68f02a55156cf783f8164cb5a4a1cb">More...</a><br /></td></tr>
<tr class="separator:aae68f02a55156cf783f8164cb5a4a1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f44fe8f905848d5c5489fe595946a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1">begin</a> ()</td></tr>
<tr class="memdesc:a70f44fe8f905848d5c5489fe595946a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the list container.  <a href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1">More...</a><br /></td></tr>
<tr class="separator:a70f44fe8f905848d5c5489fe595946a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c692df83701b7861f06253169188ec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a6c692df83701b7861f06253169188ec6">begin</a> () const</td></tr>
<tr class="memdesc:a6c692df83701b7861f06253169188ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator pointing to the first element in the list container.  <a href="classft_1_1list.html#a6c692df83701b7861f06253169188ec6">More...</a><br /></td></tr>
<tr class="separator:a6c692df83701b7861f06253169188ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a06c98fe32a1553dfd2a5d2b960efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a25a06c98fe32a1553dfd2a5d2b960efd">end</a> ()</td></tr>
<tr class="memdesc:a25a06c98fe32a1553dfd2a5d2b960efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator referring to the past-the-end element in the list container.  <a href="classft_1_1list.html#a25a06c98fe32a1553dfd2a5d2b960efd">More...</a><br /></td></tr>
<tr class="separator:a25a06c98fe32a1553dfd2a5d2b960efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a0d337c9c83d0f3dcdb1a24614a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a323a0d337c9c83d0f3dcdb1a24614a95">end</a> () const</td></tr>
<tr class="memdesc:a323a0d337c9c83d0f3dcdb1a24614a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator referring to the past-the-end element in the list container.  <a href="classft_1_1list.html#a323a0d337c9c83d0f3dcdb1a24614a95">More...</a><br /></td></tr>
<tr class="separator:a323a0d337c9c83d0f3dcdb1a24614a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9f560570c837734081891c40116cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aa2e9f560570c837734081891c40116cc">rbegin</a> ()</td></tr>
<tr class="memdesc:aa2e9f560570c837734081891c40116cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end.  <a href="classft_1_1list.html#aa2e9f560570c837734081891c40116cc">More...</a><br /></td></tr>
<tr class="separator:aa2e9f560570c837734081891c40116cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872c05512194288a08c8eadbac9b78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a6872c05512194288a08c8eadbac9b78a">rbegin</a> () const</td></tr>
<tr class="memdesc:a6872c05512194288a08c8eadbac9b78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end.  <a href="classft_1_1list.html#a6872c05512194288a08c8eadbac9b78a">More...</a><br /></td></tr>
<tr class="separator:a6872c05512194288a08c8eadbac9b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebc22ffcd3c7be498c272e2fac146f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aeebc22ffcd3c7be498c272e2fac146f4">rend</a> ()</td></tr>
<tr class="memdesc:aeebc22ffcd3c7be498c272e2fac146f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the theoretical element preceding the first element in the list container (which is considered its reverse end). The range between <a class="el" href="classft_1_1list.html#aa2e9f560570c837734081891c40116cc" title="Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning...">list::rbegin</a> and <a class="el" href="classft_1_1list.html#aeebc22ffcd3c7be498c272e2fac146f4" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the lis...">list::rend</a> contains all the elements of the container (in reverse order).  <a href="classft_1_1list.html#aeebc22ffcd3c7be498c272e2fac146f4">More...</a><br /></td></tr>
<tr class="separator:aeebc22ffcd3c7be498c272e2fac146f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6adf6bf70b2a4fcc0b2cd096c79ca3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#ac6adf6bf70b2a4fcc0b2cd096c79ca3e">rend</a> () const</td></tr>
<tr class="memdesc:ac6adf6bf70b2a4fcc0b2cd096c79ca3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator pointing to the theoretical element preceding the first element in the list container (which is considered its reverse end). The range between <a class="el" href="classft_1_1list.html#aa2e9f560570c837734081891c40116cc" title="Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning...">list::rbegin</a> and <a class="el" href="classft_1_1list.html#aeebc22ffcd3c7be498c272e2fac146f4" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the lis...">list::rend</a> contains all the elements of the container (in reverse order).  <a href="classft_1_1list.html#ac6adf6bf70b2a4fcc0b2cd096c79ca3e">More...</a><br /></td></tr>
<tr class="separator:ac6adf6bf70b2a4fcc0b2cd096c79ca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a621eed61a9bb7d939292e28e92103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a18a621eed61a9bb7d939292e28e92103">empty</a> () const</td></tr>
<tr class="memdesc:a18a621eed61a9bb7d939292e28e92103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the list container is empty (i.e. whether its size is 0).  <a href="classft_1_1list.html#a18a621eed61a9bb7d939292e28e92103">More...</a><br /></td></tr>
<tr class="separator:a18a621eed61a9bb7d939292e28e92103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8715216924c023d8a9761a163fe794ac"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a8715216924c023d8a9761a163fe794ac">size</a> () const</td></tr>
<tr class="memdesc:a8715216924c023d8a9761a163fe794ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the list container.  <a href="classft_1_1list.html#a8715216924c023d8a9761a163fe794ac">More...</a><br /></td></tr>
<tr class="separator:a8715216924c023d8a9761a163fe794ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad133d79a21146113c620840141ed571c"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#ad133d79a21146113c620840141ed571c">max_size</a> () const</td></tr>
<tr class="memdesc:ad133d79a21146113c620840141ed571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements that the list container can hold.  <a href="classft_1_1list.html#ad133d79a21146113c620840141ed571c">More...</a><br /></td></tr>
<tr class="separator:ad133d79a21146113c620840141ed571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7c2d84ffdc30027164fcfd756ab56"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#adda7c2d84ffdc30027164fcfd756ab56">front</a> ()</td></tr>
<tr class="memdesc:adda7c2d84ffdc30027164fcfd756ab56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1" title="Returns an iterator pointing to the first element in the list container.">list::begin</a>, which returns an iterator to this same element, this function returns a direct reference.  <a href="classft_1_1list.html#adda7c2d84ffdc30027164fcfd756ab56">More...</a><br /></td></tr>
<tr class="separator:adda7c2d84ffdc30027164fcfd756ab56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9a8b81fcaa350fd929f4694cfbb32c"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aad9a8b81fcaa350fd929f4694cfbb32c">front</a> () const</td></tr>
<tr class="memdesc:aad9a8b81fcaa350fd929f4694cfbb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the first element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1" title="Returns an iterator pointing to the first element in the list container.">list::begin</a>, which returns an iterator to this same element, this function returns a direct reference.  <a href="classft_1_1list.html#aad9a8b81fcaa350fd929f4694cfbb32c">More...</a><br /></td></tr>
<tr class="separator:aad9a8b81fcaa350fd929f4694cfbb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d9c197a6386ee051027aeaa00e6a77"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a69d9c197a6386ee051027aeaa00e6a77">back</a> ()</td></tr>
<tr class="memdesc:a69d9c197a6386ee051027aeaa00e6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a25a06c98fe32a1553dfd2a5d2b960efd" title="Returns an iterator referring to the past-the-end element in the list container.">list::end</a>, which returns an iterator just past this element, this function returns a direct reference.  <a href="classft_1_1list.html#a69d9c197a6386ee051027aeaa00e6a77">More...</a><br /></td></tr>
<tr class="separator:a69d9c197a6386ee051027aeaa00e6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1564adc8ff80429ac1c7972992502614"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a1564adc8ff80429ac1c7972992502614">back</a> () const</td></tr>
<tr class="memdesc:a1564adc8ff80429ac1c7972992502614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the last element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a25a06c98fe32a1553dfd2a5d2b960efd" title="Returns an iterator referring to the past-the-end element in the list container.">list::end</a>, which returns an iterator just past this element, this function returns a direct reference.  <a href="classft_1_1list.html#a1564adc8ff80429ac1c7972992502614">More...</a><br /></td></tr>
<tr class="separator:a1564adc8ff80429ac1c7972992502614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214515c8994a9d8622a470b9a16374d1"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a214515c8994a9d8622a470b9a16374d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a214515c8994a9d8622a470b9a16374d1">assign</a> (typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt; !std::numeric_limits&lt; InputIterator &gt;::is_integer, InputIterator &gt; ::type first, InputIterator last)</td></tr>
<tr class="memdesc:a214515c8994a9d8622a470b9a16374d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. the new contents are elements constructed from each of the elements in the range between first and last, in the same order, including the element pointed by first but not the element pointed by last.  <a href="classft_1_1list.html#a214515c8994a9d8622a470b9a16374d1">More...</a><br /></td></tr>
<tr class="separator:a214515c8994a9d8622a470b9a16374d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fb5e620255bd0cabd27d65d74b6554"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aa8fb5e620255bd0cabd27d65d74b6554">assign</a> (size_type n, const value_type &amp;val)</td></tr>
<tr class="memdesc:aa8fb5e620255bd0cabd27d65d74b6554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. The new contents are n elements, each initialized to a copy of val.  <a href="classft_1_1list.html#aa8fb5e620255bd0cabd27d65d74b6554">More...</a><br /></td></tr>
<tr class="separator:aa8fb5e620255bd0cabd27d65d74b6554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54458177d86117f342fd69b7e7a30d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a54458177d86117f342fd69b7e7a30d46">push_front</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a54458177d86117f342fd69b7e7a30d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the beginning of the list, right before its current first element. The content of val is copied (or moved) to the inserted element.  <a href="classft_1_1list.html#a54458177d86117f342fd69b7e7a30d46">More...</a><br /></td></tr>
<tr class="separator:a54458177d86117f342fd69b7e7a30d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffcb84ceacce368360a5a5f79d1fab8"><td class="memItemLeft" align="right" valign="top"><a id="a2ffcb84ceacce368360a5a5f79d1fab8" name="a2ffcb84ceacce368360a5a5f79d1fab8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_front</b> ()</td></tr>
<tr class="memdesc:a2ffcb84ceacce368360a5a5f79d1fab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element in the list container, effectively reducing its size by one. This destroys the removed element. <br /></td></tr>
<tr class="separator:a2ffcb84ceacce368360a5a5f79d1fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebd82536f288ec88c8d2d4387f5d465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#adebd82536f288ec88c8d2d4387f5d465">push_back</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:adebd82536f288ec88c8d2d4387f5d465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the list container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one.  <a href="classft_1_1list.html#adebd82536f288ec88c8d2d4387f5d465">More...</a><br /></td></tr>
<tr class="separator:adebd82536f288ec88c8d2d4387f5d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9a2f596fcdbc8190c3b3731efb7f94"><td class="memItemLeft" align="right" valign="top"><a id="a3b9a2f596fcdbc8190c3b3731efb7f94" name="a3b9a2f596fcdbc8190c3b3731efb7f94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="memdesc:a3b9a2f596fcdbc8190c3b3731efb7f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the list container, effectively reducing the container size by one. This destroys the removed element. <br /></td></tr>
<tr class="separator:a3b9a2f596fcdbc8190c3b3731efb7f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5138229cf572da483bc83dc9d45d55c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a5138229cf572da483bc83dc9d45d55c6">insert</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position, const value_type &amp;val)</td></tr>
<tr class="memdesc:a5138229cf572da483bc83dc9d45d55c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container is extended by inserting a new element before the element at the specified position. This effectively increases the list size by one.  <a href="classft_1_1list.html#a5138229cf572da483bc83dc9d45d55c6">More...</a><br /></td></tr>
<tr class="separator:a5138229cf572da483bc83dc9d45d55c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e8325bb1aa91555a6903b8fc841ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#ac0e8325bb1aa91555a6903b8fc841ee0">insert</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position, size_type n, const value_type &amp;val)</td></tr>
<tr class="memdesc:ac0e8325bb1aa91555a6903b8fc841ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the amount of elements inserted.  <a href="classft_1_1list.html#ac0e8325bb1aa91555a6903b8fc841ee0">More...</a><br /></td></tr>
<tr class="separator:ac0e8325bb1aa91555a6903b8fc841ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847eca65b26e36cbc8b976ecb65a58c6"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a847eca65b26e36cbc8b976ecb65a58c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a847eca65b26e36cbc8b976ecb65a58c6">insert</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position, typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt; !std::numeric_limits&lt; InputIterator &gt;::is_integer, InputIterator &gt; ::type first, InputIterator last)</td></tr>
<tr class="memdesc:a847eca65b26e36cbc8b976ecb65a58c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the amount of elements inserted. Notice that the range includes all the elements between first and last, including the element pointed by first but not the one pointed by last.  <a href="classft_1_1list.html#a847eca65b26e36cbc8b976ecb65a58c6">More...</a><br /></td></tr>
<tr class="separator:a847eca65b26e36cbc8b976ecb65a58c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158b495737adaf44c781e66d582ab5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a158b495737adaf44c781e66d582ab5e3">erase</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position)</td></tr>
<tr class="memdesc:a158b495737adaf44c781e66d582ab5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the list container a single element at position. This effectively reduces the container size by the number of elements removed, which are destroyed.  <a href="classft_1_1list.html#a158b495737adaf44c781e66d582ab5e3">More...</a><br /></td></tr>
<tr class="separator:a158b495737adaf44c781e66d582ab5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab2fc7af8af999821ee7be92a761080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aeab2fc7af8af999821ee7be92a761080">erase</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> first, <a class="el" href="classft_1_1List__iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:aeab2fc7af8af999821ee7be92a761080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the list container a range of elements ([first,last)). This effectively reduces the container size by the number of elements removed, which are destroyed. The range includes all the elements between first and last, including the element pointed by first but not the one pointed by last.  <a href="classft_1_1list.html#aeab2fc7af8af999821ee7be92a761080">More...</a><br /></td></tr>
<tr class="separator:aeab2fc7af8af999821ee7be92a761080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7b28c1fd350c87bbbd41023f550f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#ac8e7b28c1fd350c87bbbd41023f550f0">swap</a> (<a class="el" href="classft_1_1list.html">list</a> &amp;x)</td></tr>
<tr class="memdesc:ac8e7b28c1fd350c87bbbd41023f550f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the content of the container by the content of x which is another list of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in x before the call, and the elements of x are those which were in this. All iterators, references and pointers remain valid for the swapped objects.  <a href="classft_1_1list.html#ac8e7b28c1fd350c87bbbd41023f550f0">More...</a><br /></td></tr>
<tr class="separator:ac8e7b28c1fd350c87bbbd41023f550f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874d21adbbe6642ea20963942f16522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a6874d21adbbe6642ea20963942f16522">resize</a> (size_type n, value_type val=value_type())</td></tr>
<tr class="memdesc:a6874d21adbbe6642ea20963942f16522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized.  <a href="classft_1_1list.html#a6874d21adbbe6642ea20963942f16522">More...</a><br /></td></tr>
<tr class="separator:a6874d21adbbe6642ea20963942f16522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b5764c86d61281569bc950b8a9ea66"><td class="memItemLeft" align="right" valign="top"><a id="ad8b5764c86d61281569bc950b8a9ea66" name="ad8b5764c86d61281569bc950b8a9ea66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:ad8b5764c86d61281569bc950b8a9ea66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the list container (which are destroyed), and leaving the container with a size of 0. <br /></td></tr>
<tr class="separator:ad8b5764c86d61281569bc950b8a9ea66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6efe958b4909f0f5fd8082d0e9ae5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a7b6efe958b4909f0f5fd8082d0e9ae5e">splice</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position, <a class="el" href="classft_1_1list.html">list</a> &amp;x)</td></tr>
<tr class="memdesc:a7b6efe958b4909f0f5fd8082d0e9ae5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers elements from x into the container, inserting them at position. This effectively inserts those elements into the container and removes them from x, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. They are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not.  <a href="classft_1_1list.html#a7b6efe958b4909f0f5fd8082d0e9ae5e">More...</a><br /></td></tr>
<tr class="separator:a7b6efe958b4909f0f5fd8082d0e9ae5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a0886f1b2149e3b9345b5ad3095572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a89a0886f1b2149e3b9345b5ad3095572">splice</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position, <a class="el" href="classft_1_1list.html">list</a> &amp;x, <a class="el" href="classft_1_1List__iterator.html">iterator</a> i)</td></tr>
<tr class="memdesc:a89a0886f1b2149e3b9345b5ad3095572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers an element from x into the container, inserting it at position. This effectively insert this element into the container and removes it from x, altering the sizes of both containers. The operation does not involve the construction or destruction of the element. It is transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not.  <a href="classft_1_1list.html#a89a0886f1b2149e3b9345b5ad3095572">More...</a><br /></td></tr>
<tr class="separator:a89a0886f1b2149e3b9345b5ad3095572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de6a461ad2a33847a098ea00a7d7325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a1de6a461ad2a33847a098ea00a7d7325">splice</a> (<a class="el" href="classft_1_1List__iterator.html">iterator</a> position, <a class="el" href="classft_1_1list.html">list</a> &amp;x, <a class="el" href="classft_1_1List__iterator.html">iterator</a> first, <a class="el" href="classft_1_1List__iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:a1de6a461ad2a33847a098ea00a7d7325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers elements from x into the container, inserting them at position. This effectively inserts those elements into the container and removes them from x, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. They are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not.  <a href="classft_1_1list.html#a1de6a461ad2a33847a098ea00a7d7325">More...</a><br /></td></tr>
<tr class="separator:a1de6a461ad2a33847a098ea00a7d7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ef9be9960558c515f02bb4e4a813eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a20ef9be9960558c515f02bb4e4a813eb">remove</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a20ef9be9960558c515f02bb4e4a813eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed.  <a href="classft_1_1list.html#a20ef9be9960558c515f02bb4e4a813eb">More...</a><br /></td></tr>
<tr class="separator:a20ef9be9960558c515f02bb4e4a813eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0652e4ebe171dc94d0beff079728333"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:ab0652e4ebe171dc94d0beff079728333"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#ab0652e4ebe171dc94d0beff079728333">remove_if</a> (Predicate pred)</td></tr>
<tr class="memdesc:ab0652e4ebe171dc94d0beff079728333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed.  <a href="classft_1_1list.html#ab0652e4ebe171dc94d0beff079728333">More...</a><br /></td></tr>
<tr class="separator:ab0652e4ebe171dc94d0beff079728333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89735d85f8fcc40ccb6f9a2e232c2ccc"><td class="memItemLeft" align="right" valign="top"><a id="a89735d85f8fcc40ccb6f9a2e232c2ccc" name="a89735d85f8fcc40ccb6f9a2e232c2ccc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unique</b> ()</td></tr>
<tr class="memdesc:a89735d85f8fcc40ccb6f9a2e232c2ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all but the first element from every consecutive group of equal elements in the container. Notice that an element is only removed from the list container if it compares equal to the element immediately preceding it. Thus, this function is especially useful for sorted lists. <br /></td></tr>
<tr class="separator:a89735d85f8fcc40ccb6f9a2e232c2ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a7ff7692f74cd3126ad0a914c7cc9c"><td class="memTemplParams" colspan="2">template&lt;class BinaryPredicate &gt; </td></tr>
<tr class="memitem:af8a7ff7692f74cd3126ad0a914c7cc9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#af8a7ff7692f74cd3126ad0a914c7cc9c">unique</a> (BinaryPredicate binary_pred)</td></tr>
<tr class="memdesc:af8a7ff7692f74cd3126ad0a914c7cc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(<em>i,</em>(i-1)) for all pairs of elements (where i is an iterator to an element, starting from the second) and remove i from the list if the predicate returns true.  <a href="classft_1_1list.html#af8a7ff7692f74cd3126ad0a914c7cc9c">More...</a><br /></td></tr>
<tr class="separator:af8a7ff7692f74cd3126ad0a914c7cc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac338f5da0b275217c92aea39fcb8a1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#ac338f5da0b275217c92aea39fcb8a1a4">merge</a> (<a class="el" href="classft_1_1list.html">list</a> &amp;x)</td></tr>
<tr class="memdesc:ac338f5da0b275217c92aea39fcb8a1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges x into the list by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in x (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not.  <a href="classft_1_1list.html#ac338f5da0b275217c92aea39fcb8a1a4">More...</a><br /></td></tr>
<tr class="separator:ac338f5da0b275217c92aea39fcb8a1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3514d2c1f1f1c10a24964f96f5201609"><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr class="memitem:a3514d2c1f1f1c10a24964f96f5201609"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a3514d2c1f1f1c10a24964f96f5201609">merge</a> (<a class="el" href="classft_1_1list.html">list</a> &amp;x, Compare comp)</td></tr>
<tr class="memdesc:a3514d2c1f1f1c10a24964f96f5201609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges x into the list by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in x (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not.  <a href="classft_1_1list.html#a3514d2c1f1f1c10a24964f96f5201609">More...</a><br /></td></tr>
<tr class="separator:a3514d2c1f1f1c10a24964f96f5201609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace09369612363e49ba3944581e6d62b1"><td class="memItemLeft" align="right" valign="top"><a id="ace09369612363e49ba3944581e6d62b1" name="ace09369612363e49ba3944581e6d62b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> ()</td></tr>
<tr class="memdesc:ace09369612363e49ba3944581e6d62b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the list, altering their position within the container. The sorting is performed by applying an algorithm that uses operator&lt; to compare elements. <br /></td></tr>
<tr class="separator:ace09369612363e49ba3944581e6d62b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf12c1a73b93d30cd61bf829cacfc1f"><td class="memTemplParams" colspan="2">template&lt;class Compare &gt; </td></tr>
<tr class="memitem:aacf12c1a73b93d30cd61bf829cacfc1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#aacf12c1a73b93d30cd61bf829cacfc1f">sort</a> (Compare comp)</td></tr>
<tr class="memdesc:aacf12c1a73b93d30cd61bf829cacfc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the list, altering their position within the container. The sorting is performed by applying comp to compare elements.  <a href="classft_1_1list.html#aacf12c1a73b93d30cd61bf829cacfc1f">More...</a><br /></td></tr>
<tr class="separator:aacf12c1a73b93d30cd61bf829cacfc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e86205e5efa8f86b0e23b03953b6bc"><td class="memItemLeft" align="right" valign="top"><a id="a63e86205e5efa8f86b0e23b03953b6bc" name="a63e86205e5efa8f86b0e23b03953b6bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reverse</b> ()</td></tr>
<tr class="memdesc:a63e86205e5efa8f86b0e23b03953b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the elements in the list container. <br /></td></tr>
<tr class="separator:a63e86205e5efa8f86b0e23b03953b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e90dced265feea8ba22d9d71245452"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1list.html#a92e90dced265feea8ba22d9d71245452">get_allocator</a> () const</td></tr>
<tr class="memdesc:a92e90dced265feea8ba22d9d71245452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator object associated with the list container.  <a href="classft_1_1list.html#a92e90dced265feea8ba22d9d71245452">More...</a><br /></td></tr>
<tr class="separator:a92e90dced265feea8ba22d9d71245452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class ft::list&lt; T, Alloc &gt;</div><p >Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a95e09f8039e5925a7907bd7772d3233c" name="a95e09f8039e5925a7907bd7772d3233c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e09f8039e5925a7907bd7772d3233c">&#9670;&nbsp;</a></span>list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>empty container constructor (default constructor): Constructs an empty container, with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bddedad2cfb0ca84b9f4c78c5476759" name="a1bddedad2cfb0ca84b9f4c78c5476759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bddedad2cfb0ca84b9f4c78c5476759">&#9670;&nbsp;</a></span>list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::list </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>value_type()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill constructor: Constructs a container with n elements. Each element is a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Initial container size (i.e., the number of elements in the container at construction). </td></tr>
    <tr><td class="paramname">val</td><td>Value to fill the container with. Each of the n elements in the container is initialized to a copy of this value. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b03765ecedff00ae5d405a6532b8fe" name="a55b03765ecedff00ae5d405a6532b8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b03765ecedff00ae5d405a6532b8fe">&#9670;&nbsp;</a></span>list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::list </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>range constructor: Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range, in the same order. The range includes all the elements between first and last, including the element pointed by first but not the element pointed by last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Input iterators to the initial and final positions in a range. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4ab3d40206836a01496828fcce5f4ca" name="af4ab3d40206836a01496828fcce5f4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ab3d40206836a01496828fcce5f4ca">&#9670;&nbsp;</a></span>list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor: Constructs a container with a copy of each of the elements in x, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another list object of the same type (with the same class template arguments), whose contents are either copied or acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa8fb5e620255bd0cabd27d65d74b6554" name="aa8fb5e620255bd0cabd27d65d74b6554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fb5e620255bd0cabd27d65d74b6554">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. The new contents are n elements, each initialized to a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New size for the container. </td></tr>
    <tr><td class="paramname">val</td><td>Value to fill the container with. Each of the n elements in the container will be initialized to a copy of this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a214515c8994a9d8622a470b9a16374d1" name="a214515c8994a9d8622a470b9a16374d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214515c8994a9d8622a470b9a16374d1">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt; !std::numeric_limits&lt; InputIterator &gt;::is_integer, InputIterator &gt; ::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. the new contents are elements constructed from each of the elements in the range between first and last, in the same order, including the element pointed by first but not the element pointed by last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Iterators to the initial and final positions in a sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d9c197a6386ee051027aeaa00e6a77" name="a69d9c197a6386ee051027aeaa00e6a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d9c197a6386ee051027aeaa00e6a77">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a25a06c98fe32a1553dfd2a5d2b960efd" title="Returns an iterator referring to the past-the-end element in the list container.">list::end</a>, which returns an iterator just past this element, this function returns a direct reference. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last element in the list. </dd></dl>

</div>
</div>
<a id="a1564adc8ff80429ac1c7972992502614" name="a1564adc8ff80429ac1c7972992502614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1564adc8ff80429ac1c7972992502614">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the last element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a25a06c98fe32a1553dfd2a5d2b960efd" title="Returns an iterator referring to the past-the-end element in the list container.">list::end</a>, which returns an iterator just past this element, this function returns a direct reference. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the last element in the list. </dd></dl>

</div>
</div>
<a id="a70f44fe8f905848d5c5489fe595946a1" name="a70f44fe8f905848d5c5489fe595946a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f44fe8f905848d5c5489fe595946a1">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__iterator.html">iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the list container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the sequence container. If the container is empty, the returned iterator value shall not be dereferenced. </dd></dl>

</div>
</div>
<a id="a6c692df83701b7861f06253169188ec6" name="a6c692df83701b7861f06253169188ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c692df83701b7861f06253169188ec6">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator pointing to the first element in the list container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_iterator to the beginning of the sequence container. If the container is empty, the returned iterator value shall not be dereferenced. </dd></dl>

</div>
</div>
<a id="a18a621eed61a9bb7d939292e28e92103" name="a18a621eed61a9bb7d939292e28e92103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a621eed61a9bb7d939292e28e92103">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the list container is empty (i.e. whether its size is 0). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container size is 0, false otherwise. </dd></dl>

</div>
</div>
<a id="a25a06c98fe32a1553dfd2a5d2b960efd" name="a25a06c98fe32a1553dfd2a5d2b960efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a06c98fe32a1553dfd2a5d2b960efd">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__iterator.html">iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator referring to the past-the-end element in the list container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element past the end of the sequence. If the container is empty, this function returns the same as <a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1" title="Returns an iterator pointing to the first element in the list container.">list::begin</a>. </dd></dl>

</div>
</div>
<a id="a323a0d337c9c83d0f3dcdb1a24614a95" name="a323a0d337c9c83d0f3dcdb1a24614a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323a0d337c9c83d0f3dcdb1a24614a95">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator referring to the past-the-end element in the list container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_iterator to the element past the end of the sequence. If the container is empty, this function returns the same as <a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1" title="Returns an iterator pointing to the first element in the list container.">list::begin</a>. </dd></dl>

</div>
</div>
<a id="aeab2fc7af8af999821ee7be92a761080" name="aeab2fc7af8af999821ee7be92a761080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab2fc7af8af999821ee7be92a761080">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__iterator.html">iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the list container a range of elements ([first,last)). This effectively reduces the container size by the number of elements removed, which are destroyed. The range includes all the elements between first and last, including the element pointed by first but not the one pointed by last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Iterators to the initial and final positions in a range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="a158b495737adaf44c781e66d582ab5e3" name="a158b495737adaf44c781e66d582ab5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158b495737adaf44c781e66d582ab5e3">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__iterator.html">iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the list container a single element at position. This effectively reduces the container size by the number of elements removed, which are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to a single element to be removed from the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="adda7c2d84ffdc30027164fcfd756ab56" name="adda7c2d84ffdc30027164fcfd756ab56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda7c2d84ffdc30027164fcfd756ab56">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1" title="Returns an iterator pointing to the first element in the list container.">list::begin</a>, which returns an iterator to this same element, this function returns a direct reference. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first element in the list container. </dd></dl>

</div>
</div>
<a id="aad9a8b81fcaa350fd929f4694cfbb32c" name="aad9a8b81fcaa350fd929f4694cfbb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9a8b81fcaa350fd929f4694cfbb32c">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the first element in the list container. Unlike member <a class="el" href="classft_1_1list.html#a70f44fe8f905848d5c5489fe595946a1" title="Returns an iterator pointing to the first element in the list container.">list::begin</a>, which returns an iterator to this same element, this function returns a direct reference. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the first element in the list container. </dd></dl>

</div>
</div>
<a id="a92e90dced265feea8ba22d9d71245452" name="a92e90dced265feea8ba22d9d71245452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e90dced265feea8ba22d9d71245452">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the allocator object associated with the list container. </p>
<dl class="section return"><dt>Returns</dt><dd>The allocator. </dd></dl>

</div>
</div>
<a id="a5138229cf572da483bc83dc9d45d55c6" name="a5138229cf572da483bc83dc9d45d55c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5138229cf572da483bc83dc9d45d55c6">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__iterator.html">iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The container is extended by inserting a new element before the element at the specified position. This effectively increases the list size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the container where the new element is inserted. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be copied or moved to the inserted element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted element. </dd></dl>

</div>
</div>
<a id="ac0e8325bb1aa91555a6903b8fc841ee0" name="ac0e8325bb1aa91555a6903b8fc841ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e8325bb1aa91555a6903b8fc841ee0">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the amount of elements inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the container where the new elements are inserted. </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to insert. Each element is initialized to a copy of val. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be copied or moved to the inserted elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a847eca65b26e36cbc8b976ecb65a58c6" name="a847eca65b26e36cbc8b976ecb65a58c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847eca65b26e36cbc8b976ecb65a58c6">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt; !std::numeric_limits&lt; InputIterator &gt;::is_integer, InputIterator &gt; ::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the amount of elements inserted. Notice that the range includes all the elements between first and last, including the element pointed by first but not the one pointed by last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the container where the new elements are inserted. </td></tr>
    <tr><td class="paramname">first,last</td><td>Iterators to the initial and final positions in a range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad133d79a21146113c620840141ed571c" name="ad133d79a21146113c620840141ed571c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad133d79a21146113c620840141ed571c">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements that the list container can hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements the object can hold as content. </dd></dl>

</div>
</div>
<a id="ac338f5da0b275217c92aea39fcb8a1a4" name="ac338f5da0b275217c92aea39fcb8a1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac338f5da0b275217c92aea39fcb8a1a4">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges x into the list by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in x (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A list object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3514d2c1f1f1c10a24964f96f5201609" name="a3514d2c1f1f1c10a24964f96f5201609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3514d2c1f1f1c10a24964f96f5201609">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges x into the list by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in x (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A list object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
    <tr><td class="paramname">comp</td><td>Binary predicate that, taking two values of the same type than those contained in the list, returns true if the first argument is considered to go before the second in the strict weak ordering it defines, and false otherwise. This shall be a function pointer or a function object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae68f02a55156cf783f8164cb5a4a1cb" name="aae68f02a55156cf783f8164cb5a4a1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae68f02a55156cf783f8164cb5a4a1cb">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1list.html">list</a> &amp; <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. The container preserves its current allocator, which is used to allocate additional storage if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A list object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adebd82536f288ec88c8d2d4387f5d465" name="adebd82536f288ec88c8d2d4387f5d465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebd82536f288ec88c8d2d4387f5d465">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new element at the end of the list container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to be copied (or moved) to the new element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54458177d86117f342fd69b7e7a30d46" name="a54458177d86117f342fd69b7e7a30d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54458177d86117f342fd69b7e7a30d46">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at the beginning of the list, right before its current first element. The content of val is copied (or moved) to the inserted element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e9f560570c837734081891c40116cc" name="aa2e9f560570c837734081891c40116cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e9f560570c837734081891c40116cc">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__reverse__iterator.html">reverse_iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end. </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse_iterator to the reverse beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a6872c05512194288a08c8eadbac9b78a" name="a6872c05512194288a08c8eadbac9b78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6872c05512194288a08c8eadbac9b78a">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reverse_iterator to the reverse beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a20ef9be9960558c515f02bb4e4a813eb" name="a20ef9be9960558c515f02bb4e4a813eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ef9be9960558c515f02bb4e4a813eb">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value of the elements to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0652e4ebe171dc94d0beff079728333" name="ab0652e4ebe171dc94d0beff079728333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0652e4ebe171dc94d0beff079728333">&#9670;&nbsp;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>Unary predicate that, taking a value of the same type as those contained in the forward_list object, returns true for those values to be removed from the container, and false for those remaining. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeebc22ffcd3c7be498c272e2fac146f4" name="aeebc22ffcd3c7be498c272e2fac146f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebc22ffcd3c7be498c272e2fac146f4">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__reverse__iterator.html">reverse_iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the theoretical element preceding the first element in the list container (which is considered its reverse end). The range between <a class="el" href="classft_1_1list.html#aa2e9f560570c837734081891c40116cc" title="Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning...">list::rbegin</a> and <a class="el" href="classft_1_1list.html#aeebc22ffcd3c7be498c272e2fac146f4" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the lis...">list::rend</a> contains all the elements of the container (in reverse order). </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse_iterator to the reverse end of the sequence container. </dd></dl>

</div>
</div>
<a id="ac6adf6bf70b2a4fcc0b2cd096c79ca3e" name="ac6adf6bf70b2a4fcc0b2cd096c79ca3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6adf6bf70b2a4fcc0b2cd096c79ca3e">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1List__const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator pointing to the theoretical element preceding the first element in the list container (which is considered its reverse end). The range between <a class="el" href="classft_1_1list.html#aa2e9f560570c837734081891c40116cc" title="Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning...">list::rbegin</a> and <a class="el" href="classft_1_1list.html#aeebc22ffcd3c7be498c272e2fac146f4" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the lis...">list::rend</a> contains all the elements of the container (in reverse order). </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reverse_iterator to the reverse end of the sequence container. </dd></dl>

</div>
</div>
<a id="a6874d21adbbe6642ea20963942f16522" name="a6874d21adbbe6642ea20963942f16522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6874d21adbbe6642ea20963942f16522">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em> = <code>value_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New container size, expressed in number of elements. </td></tr>
    <tr><td class="paramname">val</td><td>Object whose content is copied to the added elements in case that n is greater than the current container size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8715216924c023d8a9761a163fe794ac" name="a8715216924c023d8a9761a163fe794ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8715216924c023d8a9761a163fe794ac">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the list container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="aacf12c1a73b93d30cd61bf829cacfc1f" name="aacf12c1a73b93d30cd61bf829cacfc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf12c1a73b93d30cd61bf829cacfc1f">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements in the list, altering their position within the container. The sorting is performed by applying comp to compare elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>Binary predicate that, taking two values of the same type of those contained in the list, returns true if the first argument goes before the second argument in the strict weak ordering it defines, and false otherwise. This shall be a function pointer or a function object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b6efe958b4909f0f5fd8082d0e9ae5e" name="a7b6efe958b4909f0f5fd8082d0e9ae5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6efe958b4909f0f5fd8082d0e9ae5e">&#9670;&nbsp;</a></span>splice() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers elements from x into the container, inserting them at position. This effectively inserts those elements into the container and removes them from x, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. They are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position within the container where the elements of x are inserted. </td></tr>
    <tr><td class="paramname">x</td><td>A list object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1de6a461ad2a33847a098ea00a7d7325" name="a1de6a461ad2a33847a098ea00a7d7325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de6a461ad2a33847a098ea00a7d7325">&#9670;&nbsp;</a></span>splice() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers elements from x into the container, inserting them at position. This effectively inserts those elements into the container and removes them from x, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. They are transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position within the container where the elements of x are inserted. </td></tr>
    <tr><td class="paramname">x</td><td>A list object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
    <tr><td class="paramname">first,last</td><td>Iterators to the initial and final positions in a range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89a0886f1b2149e3b9345b5ad3095572" name="a89a0886f1b2149e3b9345b5ad3095572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a0886f1b2149e3b9345b5ad3095572">&#9670;&nbsp;</a></span>splice() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1List__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers an element from x into the container, inserting it at position. This effectively insert this element into the container and removes it from x, altering the sizes of both containers. The operation does not involve the construction or destruction of the element. It is transferred, no matter whether x is an lvalue or an rvalue, or whether the value_type supports move-construction or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position within the container where the element of x is inserted. </td></tr>
    <tr><td class="paramname">x</td><td>A list object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
    <tr><td class="paramname">i</td><td>Iterator to an element in x. Only this single element is transferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e7b28c1fd350c87bbbd41023f550f0" name="ac8e7b28c1fd350c87bbbd41023f550f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e7b28c1fd350c87bbbd41023f550f0">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1list.html">list</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the content of the container by the content of x which is another list of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in x before the call, and the elements of x are those which were in this. All iterators, references and pointers remain valid for the swapped objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another list container of the same type as this (i.e., with the same template parameters, T and Alloc) whose content is swapped with that of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a7ff7692f74cd3126ad0a914c7cc9c" name="af8a7ff7692f74cd3126ad0a914c7cc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a7ff7692f74cd3126ad0a914c7cc9c">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class BinaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1list.html">ft::list</a>&lt; T, Alloc &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>binary_pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(<em>i,</em>(i-1)) for all pairs of elements (where i is an iterator to an element, starting from the second) and remove i from the list if the predicate returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary_pred</td><td>Binary predicate that, taking two values of the same type than those contained in the list, returns true to remove the element passed as first argument from the container, and false otherwise. This shall be a function pointer or a function object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>incs/<a class="el" href="list_8hpp_source.html">list.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
