<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ft_container: ft::map&lt; Key, T, Compare, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ft_container<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ft</b></li><li class="navelem"><a class="el" href="classft_1_1map.html">map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classft_1_1map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ft::map&lt; Key, T, Compare, Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order. In a map, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both: typedef <a class="el" href="structft_1_1pair.html">pair&lt;const Key, T&gt;</a> value_type;.  
 <a href="classft_1_1map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="map_8hpp_source.html">map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map_1_1value__compare.html">value_compare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3fecd256f7020ece9b2923d83601d8ea"><td class="memItemLeft" align="right" valign="top"><a id="a3fecd256f7020ece9b2923d83601d8ea" name="a3fecd256f7020ece9b2923d83601d8ea"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a3fecd256f7020ece9b2923d83601d8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6357dc42ffb0452763979dbe02a391"><td class="memItemLeft" align="right" valign="top"><a id="abc6357dc42ffb0452763979dbe02a391" name="abc6357dc42ffb0452763979dbe02a391"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr class="separator:abc6357dc42ffb0452763979dbe02a391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a892301c6f46052f2c8283885c2164"><td class="memItemLeft" align="right" valign="top"><a id="a44a892301c6f46052f2c8283885c2164" name="a44a892301c6f46052f2c8283885c2164"></a>
typedef <a class="el" href="structft_1_1pair.html">ft::pair</a>&lt; const key_type, mapped_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a44a892301c6f46052f2c8283885c2164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bee0976c83f026319d95e6047eea8c"><td class="memItemLeft" align="right" valign="top"><a id="a00bee0976c83f026319d95e6047eea8c" name="a00bee0976c83f026319d95e6047eea8c"></a>
typedef Compare&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare</b></td></tr>
<tr class="separator:a00bee0976c83f026319d95e6047eea8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc67ca35141ce774da34a7805fec34d"><td class="memItemLeft" align="right" valign="top"><a id="aefc67ca35141ce774da34a7805fec34d" name="aefc67ca35141ce774da34a7805fec34d"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:aefc67ca35141ce774da34a7805fec34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0c54e995752fd5e29175288f044869"><td class="memItemLeft" align="right" valign="top"><a id="a8f0c54e995752fd5e29175288f044869" name="a8f0c54e995752fd5e29175288f044869"></a>
typedef Alloc::template rebind&lt; Node &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><b>Node_allocator</b></td></tr>
<tr class="separator:a8f0c54e995752fd5e29175288f044869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ab623fce30de48520aad7a7e80535c"><td class="memItemLeft" align="right" valign="top"><a id="a32ab623fce30de48520aad7a7e80535c" name="a32ab623fce30de48520aad7a7e80535c"></a>
typedef allocator_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a32ab623fce30de48520aad7a7e80535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd07af9900ca45de8d6ba1d355e2b33"><td class="memItemLeft" align="right" valign="top"><a id="adcd07af9900ca45de8d6ba1d355e2b33" name="adcd07af9900ca45de8d6ba1d355e2b33"></a>
typedef allocator_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:adcd07af9900ca45de8d6ba1d355e2b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cd1deb95dd8b920e11897fa35e9a7b"><td class="memItemLeft" align="right" valign="top"><a id="a45cd1deb95dd8b920e11897fa35e9a7b" name="a45cd1deb95dd8b920e11897fa35e9a7b"></a>
typedef allocator_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a45cd1deb95dd8b920e11897fa35e9a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0ecf7f48decba2d8061442a8f4b625"><td class="memItemLeft" align="right" valign="top"><a id="aca0ecf7f48decba2d8061442a8f4b625" name="aca0ecf7f48decba2d8061442a8f4b625"></a>
typedef allocator_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:aca0ecf7f48decba2d8061442a8f4b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070328816a8989da65982442fc0fb1c2"><td class="memItemLeft" align="right" valign="top"><a id="a070328816a8989da65982442fc0fb1c2" name="a070328816a8989da65982442fc0fb1c2"></a>
typedef <a class="el" href="classft_1_1Map__iterator.html">Map_iterator</a>&lt; Key, T, Compare, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a070328816a8989da65982442fc0fb1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c05c943407c29073756212efa0b4233"><td class="memItemLeft" align="right" valign="top"><a id="a5c05c943407c29073756212efa0b4233" name="a5c05c943407c29073756212efa0b4233"></a>
typedef <a class="el" href="classft_1_1Map__const__iterator.html">Map_const_iterator</a>&lt; Key, T, Compare, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a5c05c943407c29073756212efa0b4233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84eeaf7eb676260b81bfdb0ee498332"><td class="memItemLeft" align="right" valign="top"><a id="af84eeaf7eb676260b81bfdb0ee498332" name="af84eeaf7eb676260b81bfdb0ee498332"></a>
typedef <a class="el" href="classft_1_1Map__const__reverse__iterator.html">Map_const_reverse_iterator</a>&lt; Key, T, Compare, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:af84eeaf7eb676260b81bfdb0ee498332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e16a0005ce2c66a79f3fffcafecda1a"><td class="memItemLeft" align="right" valign="top"><a id="a2e16a0005ce2c66a79f3fffcafecda1a" name="a2e16a0005ce2c66a79f3fffcafecda1a"></a>
typedef <a class="el" href="classft_1_1Map__reverse__iterator.html">Map_reverse_iterator</a>&lt; Key, T, Compare, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a2e16a0005ce2c66a79f3fffcafecda1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6ff1cc56dcc4ddc52890b07f83d1d"><td class="memItemLeft" align="right" valign="top"><a id="a77d6ff1cc56dcc4ddc52890b07f83d1d" name="a77d6ff1cc56dcc4ddc52890b07f83d1d"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a77d6ff1cc56dcc4ddc52890b07f83d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0b3a35413acf3d5ee2b5dcae2daa7c"><td class="memItemLeft" align="right" valign="top"><a id="afb0b3a35413acf3d5ee2b5dcae2daa7c" name="afb0b3a35413acf3d5ee2b5dcae2daa7c"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:afb0b3a35413acf3d5ee2b5dcae2daa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2731bf0e6f64eaa22dbd1e4734e49ece"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a2731bf0e6f64eaa22dbd1e4734e49ece">map</a> (const key_compare &amp;comp=key_compare(), const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a2731bf0e6f64eaa22dbd1e4734e49ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty container constructor (default constructor): Constructs an empty container, with no elements.  <a href="classft_1_1map.html#a2731bf0e6f64eaa22dbd1e4734e49ece">More...</a><br /></td></tr>
<tr class="separator:a2731bf0e6f64eaa22dbd1e4734e49ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f8a9891edc2ca3d99da1286ef9b228"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aa4f8a9891edc2ca3d99da1286ef9b228"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#aa4f8a9891edc2ca3d99da1286ef9b228">map</a> (typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type first, InputIterator last, const key_compare &amp;comp=key_compare(), const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:aa4f8a9891edc2ca3d99da1286ef9b228"><td class="mdescLeft">&#160;</td><td class="mdescRight">range constructor: Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range.  <a href="classft_1_1map.html#aa4f8a9891edc2ca3d99da1286ef9b228">More...</a><br /></td></tr>
<tr class="separator:aa4f8a9891edc2ca3d99da1286ef9b228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca173920f33ebf4ef7b1f1b82fc16b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#adfca173920f33ebf4ef7b1f1b82fc16b">map</a> (const <a class="el" href="classft_1_1map.html">map</a> &amp;x)</td></tr>
<tr class="memdesc:adfca173920f33ebf4ef7b1f1b82fc16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: Constructs a container with a copy of each of the elements in x.  <a href="classft_1_1map.html#adfca173920f33ebf4ef7b1f1b82fc16b">More...</a><br /></td></tr>
<tr class="separator:adfca173920f33ebf4ef7b1f1b82fc16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaf52985fe1d685b7a734589bbcdef1"><td class="memItemLeft" align="right" valign="top"><a id="a9eaf52985fe1d685b7a734589bbcdef1" name="a9eaf52985fe1d685b7a734589bbcdef1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~map</b> ()</td></tr>
<tr class="memdesc:a9eaf52985fe1d685b7a734589bbcdef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map destructor: Destroys the container object. This destroys all container elements, and deallocates all the storage capacity allocated by the map container using its allocator. <br /></td></tr>
<tr class="separator:a9eaf52985fe1d685b7a734589bbcdef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aecb2dc8153d9cbec252a3c9d4818a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1map.html">map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a02aecb2dc8153d9cbec252a3c9d4818a">operator=</a> (const <a class="el" href="classft_1_1map.html">map</a> &amp;x)</td></tr>
<tr class="memdesc:a02aecb2dc8153d9cbec252a3c9d4818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the elements from x into the container, changing its size accordingly.  <a href="classft_1_1map.html#a02aecb2dc8153d9cbec252a3c9d4818a">More...</a><br /></td></tr>
<tr class="separator:a02aecb2dc8153d9cbec252a3c9d4818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95314d0d74ad6cc678409a524006c748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a95314d0d74ad6cc678409a524006c748">begin</a> ()</td></tr>
<tr class="memdesc:a95314d0d74ad6cc678409a524006c748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator referring to the first element in the map container.  <a href="classft_1_1map.html#a95314d0d74ad6cc678409a524006c748">More...</a><br /></td></tr>
<tr class="separator:a95314d0d74ad6cc678409a524006c748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1c3f066c5c893b303e7225a17586a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a4f1c3f066c5c893b303e7225a17586a9">begin</a> () const</td></tr>
<tr class="memdesc:a4f1c3f066c5c893b303e7225a17586a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator referring to the first element in the map container.  <a href="classft_1_1map.html#a4f1c3f066c5c893b303e7225a17586a9">More...</a><br /></td></tr>
<tr class="separator:a4f1c3f066c5c893b303e7225a17586a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af460e1d9fb1a2d10c9d8da62df765c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d">end</a> ()</td></tr>
<tr class="memdesc:af460e1d9fb1a2d10c9d8da62df765c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator referring to the past-the-end element in the map container.  <a href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d">More...</a><br /></td></tr>
<tr class="separator:af460e1d9fb1a2d10c9d8da62df765c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e77c8f3c8a5b162f7e3b1d74351254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a23e77c8f3c8a5b162f7e3b1d74351254">end</a> () const</td></tr>
<tr class="memdesc:a23e77c8f3c8a5b162f7e3b1d74351254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator referring to the past-the-end element in the map container.  <a href="classft_1_1map.html#a23e77c8f3c8a5b162f7e3b1d74351254">More...</a><br /></td></tr>
<tr class="separator:a23e77c8f3c8a5b162f7e3b1d74351254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5635f931845dbc3c46de28323f389fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a5635f931845dbc3c46de28323f389fb2">rbegin</a> ()</td></tr>
<tr class="memdesc:a5635f931845dbc3c46de28323f389fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning).  <a href="classft_1_1map.html#a5635f931845dbc3c46de28323f389fb2">More...</a><br /></td></tr>
<tr class="separator:a5635f931845dbc3c46de28323f389fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88334962d2893c41a7789a15b293ae56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a88334962d2893c41a7789a15b293ae56">rbegin</a> () const</td></tr>
<tr class="memdesc:a88334962d2893c41a7789a15b293ae56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator pointing to the last element in the container (i.e., its reverse beginning).  <a href="classft_1_1map.html#a88334962d2893c41a7789a15b293ae56">More...</a><br /></td></tr>
<tr class="separator:a88334962d2893c41a7789a15b293ae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474e2af4c7d2e7e7471e620c9f90f900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a474e2af4c7d2e7e7471e620c9f90f900">rend</a> ()</td></tr>
<tr class="memdesc:a474e2af4c7d2e7e7471e620c9f90f900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the theoretical element right before the first element in the map container (which is considered its reverse end).  <a href="classft_1_1map.html#a474e2af4c7d2e7e7471e620c9f90f900">More...</a><br /></td></tr>
<tr class="separator:a474e2af4c7d2e7e7471e620c9f90f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5a0ea4c1728b2fdd85f118a4949d6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#aad5a0ea4c1728b2fdd85f118a4949d6d">rend</a> () const</td></tr>
<tr class="memdesc:aad5a0ea4c1728b2fdd85f118a4949d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator pointing to the theoretical element right before the first element in the map container (which is considered its reverse end).  <a href="classft_1_1map.html#aad5a0ea4c1728b2fdd85f118a4949d6d">More...</a><br /></td></tr>
<tr class="separator:aad5a0ea4c1728b2fdd85f118a4949d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb1d163c34ef4c5167b54d4704debb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#abcb1d163c34ef4c5167b54d4704debb0">empty</a> () const</td></tr>
<tr class="memdesc:abcb1d163c34ef4c5167b54d4704debb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the map container is empty (i.e. whether its size is 0).  <a href="classft_1_1map.html#abcb1d163c34ef4c5167b54d4704debb0">More...</a><br /></td></tr>
<tr class="separator:abcb1d163c34ef4c5167b54d4704debb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5fd2678d67992c3aa87f30c3323923"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a5c5fd2678d67992c3aa87f30c3323923">size</a> () const</td></tr>
<tr class="memdesc:a5c5fd2678d67992c3aa87f30c3323923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the map container.  <a href="classft_1_1map.html#a5c5fd2678d67992c3aa87f30c3323923">More...</a><br /></td></tr>
<tr class="separator:a5c5fd2678d67992c3aa87f30c3323923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca926c2df89f25cccba1e3e5e6868729"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#aca926c2df89f25cccba1e3e5e6868729">max_size</a> () const</td></tr>
<tr class="memdesc:aca926c2df89f25cccba1e3e5e6868729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements that the map container can hold.  <a href="classft_1_1map.html#aca926c2df89f25cccba1e3e5e6868729">More...</a><br /></td></tr>
<tr class="separator:aca926c2df89f25cccba1e3e5e6868729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658d69b2b9daec0d452201a7ceaa2ad1"><td class="memItemLeft" align="right" valign="top"><a id="a658d69b2b9daec0d452201a7ceaa2ad1" name="a658d69b2b9daec0d452201a7ceaa2ad1"></a>
mapped_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const key_type &amp;k)</td></tr>
<tr class="memdesc:a658d69b2b9daec0d452201a7ceaa2ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If k matches the key of an element in the container, the function returns a reference to its mapped value. If k does not match the key of any element in the container, the function inserts a new element with that key and returns a reference to its mapped value. <br /></td></tr>
<tr class="separator:a658d69b2b9daec0d452201a7ceaa2ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08cbcf4eb3f97de2ab2c81c5ceadacb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structft_1_1pair.html">pair</a>&lt; <a class="el" href="classft_1_1Map__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#ab08cbcf4eb3f97de2ab2c81c5ceadacb">insert</a> (const <a class="el" href="structft_1_1pair.html">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ab08cbcf4eb3f97de2ab2c81c5ceadacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the container by inserting new elements, effectively increasing the container size by one.  <a href="classft_1_1map.html#ab08cbcf4eb3f97de2ab2c81c5ceadacb">More...</a><br /></td></tr>
<tr class="separator:ab08cbcf4eb3f97de2ab2c81c5ceadacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e3aa8b1a640a04995da30f0f58254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a6b3e3aa8b1a640a04995da30f0f58254">insert</a> (<a class="el" href="classft_1_1Map__iterator.html">iterator</a> position, const <a class="el" href="structft_1_1pair.html">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a6b3e3aa8b1a640a04995da30f0f58254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the container by inserting new elements, effectively increasing the container size by one.  <a href="classft_1_1map.html#a6b3e3aa8b1a640a04995da30f0f58254">More...</a><br /></td></tr>
<tr class="separator:a6b3e3aa8b1a640a04995da30f0f58254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa89da204e676b50e461ea1db9839f0a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:aaa89da204e676b50e461ea1db9839f0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#aaa89da204e676b50e461ea1db9839f0a">insert</a> (typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type first, InputIterator last)</td></tr>
<tr class="memdesc:aaa89da204e676b50e461ea1db9839f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the container by inserting new elements, effectively increasing the container size by the number of elements inserted.  <a href="classft_1_1map.html#aaa89da204e676b50e461ea1db9839f0a">More...</a><br /></td></tr>
<tr class="separator:aaa89da204e676b50e461ea1db9839f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3112740afdae34bb8ffb224b2be5700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#aa3112740afdae34bb8ffb224b2be5700">erase</a> (<a class="el" href="classft_1_1Map__iterator.html">iterator</a> position)</td></tr>
<tr class="memdesc:aa3112740afdae34bb8ffb224b2be5700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single element from the map container. This effectively reduces the container size by one and destroy the element.  <a href="classft_1_1map.html#aa3112740afdae34bb8ffb224b2be5700">More...</a><br /></td></tr>
<tr class="separator:aa3112740afdae34bb8ffb224b2be5700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0aa8c7dc3f7e4b885d4a0cc58b47fb"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a4a0aa8c7dc3f7e4b885d4a0cc58b47fb">erase</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:a4a0aa8c7dc3f7e4b885d4a0cc58b47fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single element from the map container. This effectively reduces the container size by one and destroy the element.  <a href="classft_1_1map.html#a4a0aa8c7dc3f7e4b885d4a0cc58b47fb">More...</a><br /></td></tr>
<tr class="separator:a4a0aa8c7dc3f7e4b885d4a0cc58b47fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1fa5acf0bda758768ffe790cc23dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#af3b1fa5acf0bda758768ffe790cc23dc">erase</a> (<a class="el" href="classft_1_1Map__iterator.html">iterator</a> first, <a class="el" href="classft_1_1Map__iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:af3b1fa5acf0bda758768ffe790cc23dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the map container a range of elements ([first,last)). This effectively reduces the container size by the number of elements removed, which are destroyed.  <a href="classft_1_1map.html#af3b1fa5acf0bda758768ffe790cc23dc">More...</a><br /></td></tr>
<tr class="separator:af3b1fa5acf0bda758768ffe790cc23dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28f645a8bb1bc052b225c84eaa44f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#ae28f645a8bb1bc052b225c84eaa44f1e">swap</a> (<a class="el" href="classft_1_1map.html">map</a> &amp;x)</td></tr>
<tr class="memdesc:ae28f645a8bb1bc052b225c84eaa44f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the content of the container by the content of x, which is another map of the same type. Sizes may differ.  <a href="classft_1_1map.html#ae28f645a8bb1bc052b225c84eaa44f1e">More...</a><br /></td></tr>
<tr class="separator:ae28f645a8bb1bc052b225c84eaa44f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca977a9ca5f3dd8a35e2e32c01c15ee"><td class="memItemLeft" align="right" valign="top"><a id="a8ca977a9ca5f3dd8a35e2e32c01c15ee" name="a8ca977a9ca5f3dd8a35e2e32c01c15ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a8ca977a9ca5f3dd8a35e2e32c01c15ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the map container (which are destroyed), leaving the container with a size of 0. <br /></td></tr>
<tr class="separator:a8ca977a9ca5f3dd8a35e2e32c01c15ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d7144236cf0dbd045654a3733f327c"><td class="memItemLeft" align="right" valign="top">key_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a70d7144236cf0dbd045654a3733f327c">key_comp</a> () const</td></tr>
<tr class="memdesc:a70d7144236cf0dbd045654a3733f327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the comparison object used by the container to compare keys.  <a href="classft_1_1map.html#a70d7144236cf0dbd045654a3733f327c">More...</a><br /></td></tr>
<tr class="separator:a70d7144236cf0dbd045654a3733f327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab736503670cc1bde1c106494c3581e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1map_1_1value__compare.html">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#ab736503670cc1bde1c106494c3581e46">value_comp</a> () const</td></tr>
<tr class="memdesc:ab736503670cc1bde1c106494c3581e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a comparison object that can be used to compare two elements to get whether the key of the first one goes before the second.  <a href="classft_1_1map.html#ab736503670cc1bde1c106494c3581e46">More...</a><br /></td></tr>
<tr class="separator:ab736503670cc1bde1c106494c3581e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28e551c1ab44343bd3d5f6e7c9d8086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#ae28e551c1ab44343bd3d5f6e7c9d8086">find</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:ae28e551c1ab44343bd3d5f6e7c9d8086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the container for an element with a key equivalent to k and returns an iterator to it if found, otherwise it returns an iterator to <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a>.  <a href="classft_1_1map.html#ae28e551c1ab44343bd3d5f6e7c9d8086">More...</a><br /></td></tr>
<tr class="separator:ae28e551c1ab44343bd3d5f6e7c9d8086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e52f208d8d5a22866f02f5b9b0ab3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a09e52f208d8d5a22866f02f5b9b0ab3a">find</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a09e52f208d8d5a22866f02f5b9b0ab3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the container for an element with a key equivalent to k and returns a const iterator to it if found, otherwise it returns a const iterator to <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a>.  <a href="classft_1_1map.html#a09e52f208d8d5a22866f02f5b9b0ab3a">More...</a><br /></td></tr>
<tr class="separator:a09e52f208d8d5a22866f02f5b9b0ab3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e66b2a17bdcae1769b8df5ebcb36dd"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a95e66b2a17bdcae1769b8df5ebcb36dd">count</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a95e66b2a17bdcae1769b8df5ebcb36dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the container for elements with a key equivalent to k and returns the number of matches.  <a href="classft_1_1map.html#a95e66b2a17bdcae1769b8df5ebcb36dd">More...</a><br /></td></tr>
<tr class="separator:a95e66b2a17bdcae1769b8df5ebcb36dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3ce8ec0cc9cd98c009f5dad2836ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#aad3ce8ec0cc9cd98c009f5dad2836ae6">lower_bound</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:aad3ce8ec0cc9cd98c009f5dad2836ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the container whose key is not considered to go before k (i.e., either it is equivalent or goes after).  <a href="classft_1_1map.html#aad3ce8ec0cc9cd98c009f5dad2836ae6">More...</a><br /></td></tr>
<tr class="separator:aad3ce8ec0cc9cd98c009f5dad2836ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da9cf1d7b779c6c05235b22f09b4de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a1da9cf1d7b779c6c05235b22f09b4de9">lower_bound</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a1da9cf1d7b779c6c05235b22f09b4de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing to the first element in the container whose key is not considered to go before k (i.e., either it is equivalent or goes after).  <a href="classft_1_1map.html#a1da9cf1d7b779c6c05235b22f09b4de9">More...</a><br /></td></tr>
<tr class="separator:a1da9cf1d7b779c6c05235b22f09b4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7203dc18336940cc940f75c3d49d9651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a7203dc18336940cc940f75c3d49d9651">upper_bound</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:a7203dc18336940cc940f75c3d49d9651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the container whose key is considered to go after k.  <a href="classft_1_1map.html#a7203dc18336940cc940f75c3d49d9651">More...</a><br /></td></tr>
<tr class="separator:a7203dc18336940cc940f75c3d49d9651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dda64e6853843d59d01d8e2922bdd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a25dda64e6853843d59d01d8e2922bdd9">upper_bound</a> (const key_type &amp;k) const</td></tr>
<tr class="separator:a25dda64e6853843d59d01d8e2922bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b10df034b4924cab12eda8c5be998c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structft_1_1pair.html">pair</a>&lt; <a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>, <a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a52b10df034b4924cab12eda8c5be998c">equal_range</a> (const key_type &amp;k) const</td></tr>
<tr class="memdesc:a52b10df034b4924cab12eda8c5be998c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounds of a range that includes all the elements in the container which have a key equivalent to k. Because the elements in a map container have unique keys, the range returned will contain a single element at most.  <a href="classft_1_1map.html#a52b10df034b4924cab12eda8c5be998c">More...</a><br /></td></tr>
<tr class="separator:a52b10df034b4924cab12eda8c5be998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18239d98bf162b498d2ee5730da1de5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structft_1_1pair.html">pair</a>&lt; <a class="el" href="classft_1_1Map__iterator.html">iterator</a>, <a class="el" href="classft_1_1Map__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a18239d98bf162b498d2ee5730da1de5c">equal_range</a> (const key_type &amp;k)</td></tr>
<tr class="memdesc:a18239d98bf162b498d2ee5730da1de5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounds of a range that includes all the elements in the container which have a key equivalent to k. Because the elements in a map container have unique keys, the range returned will contain a single element at most.  <a href="classft_1_1map.html#a18239d98bf162b498d2ee5730da1de5c">More...</a><br /></td></tr>
<tr class="separator:a18239d98bf162b498d2ee5730da1de5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869074e897ba255da288f2f3e6744eb5"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1map.html#a869074e897ba255da288f2f3e6744eb5">get_allocator</a> () const</td></tr>
<tr class="memdesc:a869074e897ba255da288f2f3e6744eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator object associated with the map.  <a href="classft_1_1map.html#a869074e897ba255da288f2f3e6744eb5">More...</a><br /></td></tr>
<tr class="separator:a869074e897ba255da288f2f3e6744eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Key, class T, class Compare = std::less&lt;Key&gt;, class Alloc = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt;<br />
class ft::map&lt; Key, T, Compare, Alloc &gt;</div><p >Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order. In a map, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both: typedef <a class="el" href="structft_1_1pair.html">pair&lt;const Key, T&gt;</a> value_type;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Type of the keys. Each element in a map is uniquely identified by its key value. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the mapped value. Each element in a map stores some data as its mapped value. </td></tr>
    <tr><td class="paramname">Compare</td><td>A binary predicate that takes two element keys as arguments and returns a bool. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of the allocator object used to define the storage allocation model. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2731bf0e6f64eaa22dbd1e4734e49ece" name="a2731bf0e6f64eaa22dbd1e4734e49ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2731bf0e6f64eaa22dbd1e4734e49ece">&#9670;&nbsp;</a></span>map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::map </td>
          <td>(</td>
          <td class="paramtype">const key_compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>key_compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>empty container constructor (default constructor): Constructs an empty container, with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>Binary predicate that, taking two element keys as argument, returns true if the first argument goes before the second argument in the strict weak ordering it defines, and false otherwise. This shall be a function pointer or a function object. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4f8a9891edc2ca3d99da1286ef9b228" name="aa4f8a9891edc2ca3d99da1286ef9b228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f8a9891edc2ca3d99da1286ef9b228">&#9670;&nbsp;</a></span>map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::map </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em> = <code>key_compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>range constructor: Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Input iterators to the initial and final positions in a range. The range used is [first,last), which includes all the elements between first and last, including the element pointed by first but not the element pointed by last. </td></tr>
    <tr><td class="paramname">comp</td><td>Binary predicate that, taking two element keys as argument, returns true if the first argument goes before the second argument in the strict weak ordering it defines, and false otherwise. This shall be a function pointer or a function object. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfca173920f33ebf4ef7b1f1b82fc16b" name="adfca173920f33ebf4ef7b1f1b82fc16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca173920f33ebf4ef7b1f1b82fc16b">&#9670;&nbsp;</a></span>map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1map.html">map</a>&lt; Key, T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: Constructs a container with a copy of each of the elements in x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another map object of the same type (with the same class template arguments Key, T, Compare and Alloc), whose contents are either copied or acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a95314d0d74ad6cc678409a524006c748" name="a95314d0d74ad6cc678409a524006c748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95314d0d74ad6cc678409a524006c748">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__iterator.html">iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator referring to the first element in the map container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first element in the container. </dd></dl>

</div>
</div>
<a id="a4f1c3f066c5c893b303e7225a17586a9" name="a4f1c3f066c5c893b303e7225a17586a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1c3f066c5c893b303e7225a17586a9">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator referring to the first element in the map container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the first element in the container. </dd></dl>

</div>
</div>
<a id="a95e66b2a17bdcae1769b8df5ebcb36dd" name="a95e66b2a17bdcae1769b8df5ebcb36dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e66b2a17bdcae1769b8df5ebcb36dd">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the container for elements with a key equivalent to k and returns the number of matches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the container contains an element whose key is equivalent to k, or zero otherwise. </dd></dl>

</div>
</div>
<a id="abcb1d163c34ef4c5167b54d4704debb0" name="abcb1d163c34ef4c5167b54d4704debb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb1d163c34ef4c5167b54d4704debb0">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the map container is empty (i.e. whether its size is 0). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container size is 0, false otherwise. </dd></dl>

</div>
</div>
<a id="af460e1d9fb1a2d10c9d8da62df765c6d" name="af460e1d9fb1a2d10c9d8da62df765c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af460e1d9fb1a2d10c9d8da62df765c6d">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__iterator.html">iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator referring to the past-the-end element in the map container. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the past-the-end element in the container. </dd></dl>

</div>
</div>
<a id="a23e77c8f3c8a5b162f7e3b1d74351254" name="a23e77c8f3c8a5b162f7e3b1d74351254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e77c8f3c8a5b162f7e3b1d74351254">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator referring to the past-the-end element in the map container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the past-the-end element in the container. </dd></dl>

</div>
</div>
<a id="a18239d98bf162b498d2ee5730da1de5c" name="a18239d98bf162b498d2ee5730da1de5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18239d98bf162b498d2ee5730da1de5c">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structft_1_1pair.html">pair</a>&lt; <a class="el" href="classft_1_1Map__iterator.html">iterator</a>, <a class="el" href="classft_1_1Map__iterator.html">iterator</a> &gt; <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bounds of a range that includes all the elements in the container which have a key equivalent to k. Because the elements in a map container have unique keys, the range returned will contain a single element at most. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a pair, whose member pair::first is the lower bound of the range (the same as lower_bound), and pair::second is the upper bound (the same as upper_bound). </dd></dl>

</div>
</div>
<a id="a52b10df034b4924cab12eda8c5be998c" name="a52b10df034b4924cab12eda8c5be998c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b10df034b4924cab12eda8c5be998c">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structft_1_1pair.html">pair</a>&lt; <a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a>, <a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> &gt; <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the bounds of a range that includes all the elements in the container which have a key equivalent to k. Because the elements in a map container have unique keys, the range returned will contain a single element at most. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a pair, whose member pair::first is the lower bound of the range (the same as lower_bound), and pair::second is the upper bound (the same as upper_bound). </dd></dl>

</div>
</div>
<a id="a4a0aa8c7dc3f7e4b885d4a0cc58b47fb" name="a4a0aa8c7dc3f7e4b885d4a0cc58b47fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0aa8c7dc3f7e4b885d4a0cc58b47fb">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single element from the map container. This effectively reduces the container size by one and destroy the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key of the element to be removed from the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3b1fa5acf0bda758768ffe790cc23dc" name="af3b1fa5acf0bda758768ffe790cc23dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b1fa5acf0bda758768ffe790cc23dc">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the map container a range of elements ([first,last)). This effectively reduces the container size by the number of elements removed, which are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Iterators specifying a range within the map container to be removed: [first,last). i.e., the range includes all the elements between first and last, including the element pointed by first but not the one pointed by last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3112740afdae34bb8ffb224b2be5700" name="aa3112740afdae34bb8ffb224b2be5700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3112740afdae34bb8ffb224b2be5700">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single element from the map container. This effectively reduces the container size by one and destroy the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Iterator pointing to a single element to be removed from the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae28e551c1ab44343bd3d5f6e7c9d8086" name="ae28e551c1ab44343bd3d5f6e7c9d8086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28e551c1ab44343bd3d5f6e7c9d8086">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__iterator.html">iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the container for an element with a key equivalent to k and returns an iterator to it if found, otherwise it returns an iterator to <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element, if an element with specified key is found, or <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a> otherwise. </dd></dl>

</div>
</div>
<a id="a09e52f208d8d5a22866f02f5b9b0ab3a" name="a09e52f208d8d5a22866f02f5b9b0ab3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e52f208d8d5a22866f02f5b9b0ab3a">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the container for an element with a key equivalent to k and returns a const iterator to it if found, otherwise it returns a const iterator to <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the element, if an element with specified key is found, or <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a> otherwise. </dd></dl>

</div>
</div>
<a id="a869074e897ba255da288f2f3e6744eb5" name="a869074e897ba255da288f2f3e6744eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869074e897ba255da288f2f3e6744eb5">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the allocator object associated with the map. </p>
<dl class="section return"><dt>Returns</dt><dd>The allocator. </dd></dl>

</div>
</div>
<a id="ab08cbcf4eb3f97de2ab2c81c5ceadacb" name="ab08cbcf4eb3f97de2ab2c81c5ceadacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cbcf4eb3f97de2ab2c81c5ceadacb">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structft_1_1pair.html">pair</a>&lt; <a class="el" href="classft_1_1Map__iterator.html">iterator</a>, bool &gt; <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structft_1_1pair.html">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the container by inserting new elements, effectively increasing the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to be copied to (or moved as) the inserted element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pair with its member pair::first set to an iterator pointing to either the newly inserted element or to the element with an equivalent key in the map. The pair::second element in the pair is set to true if a new element was inserted or false if an equivalent key already existed. </dd></dl>

</div>
</div>
<a id="a6b3e3aa8b1a640a04995da30f0f58254" name="a6b3e3aa8b1a640a04995da30f0f58254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e3aa8b1a640a04995da30f0f58254">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__iterator.html">iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Map__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structft_1_1pair.html">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the container by inserting new elements, effectively increasing the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Hint for the position where the element can be inserted. Notice that this is just a hint and does not force the new element to be inserted at that position within the map container. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be copied to (or moved as) the inserted element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa89da204e676b50e461ea1db9839f0a" name="aaa89da204e676b50e461ea1db9839f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa89da204e676b50e461ea1db9839f0a">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends the container by inserting new elements, effectively increasing the container size by the number of elements inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Iterators specifying a range of elements. Copies of the elements in the range [first,last) are inserted in the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70d7144236cf0dbd045654a3733f327c" name="a70d7144236cf0dbd045654a3733f327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d7144236cf0dbd045654a3733f327c">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">key_compare <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the comparison object used by the container to compare keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The comparison object. </dd></dl>

</div>
</div>
<a id="aad3ce8ec0cc9cd98c009f5dad2836ae6" name="aad3ce8ec0cc9cd98c009f5dad2836ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3ce8ec0cc9cd98c009f5dad2836ae6">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__iterator.html">iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the container whose key is not considered to go before k (i.e., either it is equivalent or goes after). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the the first element in the container whose key is not considered to go before k, or <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a> if all keys are considered to go before k. </dd></dl>

</div>
</div>
<a id="a1da9cf1d7b779c6c05235b22f09b4de9" name="a1da9cf1d7b779c6c05235b22f09b4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da9cf1d7b779c6c05235b22f09b4de9">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator pointing to the first element in the container whose key is not considered to go before k (i.e., either it is equivalent or goes after). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the the first element in the container whose key is not considered to go before k, or <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a> if all keys are considered to go before k. </dd></dl>

</div>
</div>
<a id="aca926c2df89f25cccba1e3e5e6868729" name="aca926c2df89f25cccba1e3e5e6868729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca926c2df89f25cccba1e3e5e6868729">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements that the map container can hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements a map container can hold as content. </dd></dl>

</div>
</div>
<a id="a02aecb2dc8153d9cbec252a3c9d4818a" name="a02aecb2dc8153d9cbec252a3c9d4818a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aecb2dc8153d9cbec252a3c9d4818a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1map.html">map</a> &amp; <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1map.html">map</a>&lt; Key, T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the elements from x into the container, changing its size accordingly. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a5635f931845dbc3c46de28323f389fb2" name="a5635f931845dbc3c46de28323f389fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5635f931845dbc3c46de28323f389fb2">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__reverse__iterator.html">reverse_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the last element in the container (i.e., its reverse beginning). </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the reverse beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a88334962d2893c41a7789a15b293ae56" name="a88334962d2893c41a7789a15b293ae56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88334962d2893c41a7789a15b293ae56">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator pointing to the last element in the container (i.e., its reverse beginning). </p>
<dl class="section return"><dt>Returns</dt><dd>A const reverse iterator to the reverse beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a474e2af4c7d2e7e7471e620c9f90f900" name="a474e2af4c7d2e7e7471e620c9f90f900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474e2af4c7d2e7e7471e620c9f90f900">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__reverse__iterator.html">reverse_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the theoretical element right before the first element in the map container (which is considered its reverse end). </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the reverse end of the sequence container. </dd></dl>

</div>
</div>
<a id="aad5a0ea4c1728b2fdd85f118a4949d6d" name="aad5a0ea4c1728b2fdd85f118a4949d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5a0ea4c1728b2fdd85f118a4949d6d">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator pointing to the theoretical element right before the first element in the map container (which is considered its reverse end). </p>
<dl class="section return"><dt>Returns</dt><dd>A const reverse iterator to the reverse end of the sequence container. </dd></dl>

</div>
</div>
<a id="a5c5fd2678d67992c3aa87f30c3323923" name="a5c5fd2678d67992c3aa87f30c3323923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5fd2678d67992c3aa87f30c3323923">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the map container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="ae28f645a8bb1bc052b225c84eaa44f1e" name="ae28f645a8bb1bc052b225c84eaa44f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28f645a8bb1bc052b225c84eaa44f1e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1map.html">map</a>&lt; Key, T, Compare, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the content of the container by the content of x, which is another map of the same type. Sizes may differ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another map container of the same type as this (i.e., with the same template parameters, Key, T, Compare and Alloc) whose content is swapped with that of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7203dc18336940cc940f75c3d49d9651" name="a7203dc18336940cc940f75c3d49d9651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7203dc18336940cc940f75c3d49d9651">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__iterator.html">iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the container whose key is considered to go after k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the the first element in the container whose key is considered to go after k, or <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a> if no keys are considered to go after k. </dd></dl>

</div>
</div>
<a id="a25dda64e6853843d59d01d8e2922bdd9" name="a25dda64e6853843d59d01d8e2922bdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dda64e6853843d59d01d8e2922bdd9">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Map__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a const iterator pointing to the first element in the container whose key is considered to go after k. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the the first element in the container whose key is considered to go after k, or <a class="el" href="classft_1_1map.html#af460e1d9fb1a2d10c9d8da62df765c6d" title="Returns an iterator referring to the past-the-end element in the map container.">map::end</a> if no keys are considered to go after k. </dd></dl>

</div>
</div>
<a id="ab736503670cc1bde1c106494c3581e46" name="ab736503670cc1bde1c106494c3581e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab736503670cc1bde1c106494c3581e46">&#9670;&nbsp;</a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class T , class Compare  = std::less&lt;Key&gt;, class Alloc  = std::allocator&lt;ft::pair&lt;const Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1map_1_1value__compare.html">value_compare</a> <a class="el" href="classft_1_1map.html">ft::map</a>&lt; Key, T, Compare, Alloc &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a comparison object that can be used to compare two elements to get whether the key of the first one goes before the second. </p>
<dl class="section return"><dt>Returns</dt><dd>The comparison object for element values. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>incs/<a class="el" href="map_8hpp_source.html">map.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
