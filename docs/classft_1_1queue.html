<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ft_container: ft::queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ft_container<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ft</b></li><li class="navelem"><a class="el" href="classft_1_1queue.html">queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classft_1_1queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ft::queue&lt; T, Container &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other. Queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front".  
 <a href="classft_1_1queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="queue_8hpp_source.html">queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a745536015813b1f509c192e0700bf5e5"><td class="memItemLeft" align="right" valign="top"><a id="a745536015813b1f509c192e0700bf5e5" name="a745536015813b1f509c192e0700bf5e5"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a745536015813b1f509c192e0700bf5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da995d90aa00403d298f77a481ac0d9"><td class="memItemLeft" align="right" valign="top"><a id="a2da995d90aa00403d298f77a481ac0d9" name="a2da995d90aa00403d298f77a481ac0d9"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><b>container_type</b></td></tr>
<tr class="separator:a2da995d90aa00403d298f77a481ac0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7e47f00d12af4839c76e8fe8749d4"><td class="memItemLeft" align="right" valign="top"><a id="a62d7e47f00d12af4839c76e8fe8749d4" name="a62d7e47f00d12af4839c76e8fe8749d4"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a62d7e47f00d12af4839c76e8fe8749d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a113a5e468b57e818125de12e98ea93cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#a113a5e468b57e818125de12e98ea93cd">queue</a> (const container_type &amp;ctnr=container_type())</td></tr>
<tr class="separator:a113a5e468b57e818125de12e98ea93cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbe4f3bd15caa14373c17fd5eb372b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#a8fbe4f3bd15caa14373c17fd5eb372b4">queue</a> (const <a class="el" href="classft_1_1queue.html">queue</a> &amp;x)</td></tr>
<tr class="memdesc:a8fbe4f3bd15caa14373c17fd5eb372b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: Constructs a container with a copy of each of the elements in x.  <a href="classft_1_1queue.html#a8fbe4f3bd15caa14373c17fd5eb372b4">More...</a><br /></td></tr>
<tr class="separator:a8fbe4f3bd15caa14373c17fd5eb372b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca62866c5e9b732ee0c20e742dd1095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1queue.html">queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#aaca62866c5e9b732ee0c20e742dd1095">operator=</a> (const <a class="el" href="classft_1_1queue.html">queue</a> &amp;x)</td></tr>
<tr class="memdesc:aaca62866c5e9b732ee0c20e742dd1095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the elements from x into the container, changing its size accordingly.  <a href="classft_1_1queue.html#aaca62866c5e9b732ee0c20e742dd1095">More...</a><br /></td></tr>
<tr class="separator:aaca62866c5e9b732ee0c20e742dd1095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cf7d446c8fb8bce14023e21788893d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#a81cf7d446c8fb8bce14023e21788893d">empty</a> () const</td></tr>
<tr class="memdesc:a81cf7d446c8fb8bce14023e21788893d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the queue is empty: i.e. whether its size is zero.  <a href="classft_1_1queue.html#a81cf7d446c8fb8bce14023e21788893d">More...</a><br /></td></tr>
<tr class="separator:a81cf7d446c8fb8bce14023e21788893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3641432645eb900b2a24227e5a9c7e"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#abf3641432645eb900b2a24227e5a9c7e">size</a> () const</td></tr>
<tr class="memdesc:abf3641432645eb900b2a24227e5a9c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the queue.  <a href="classft_1_1queue.html#abf3641432645eb900b2a24227e5a9c7e">More...</a><br /></td></tr>
<tr class="separator:abf3641432645eb900b2a24227e5a9c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e417de9378976ad4389e74002fd5e"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#ae12e417de9378976ad4389e74002fd5e">front</a> ()</td></tr>
<tr class="memdesc:ae12e417de9378976ad4389e74002fd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the next element in the queue. The next element is the "oldest" element in the queue and the same element that is popped out from the queue when <a class="el" href="classft_1_1queue.html#ac3b7cf57b3541f9f4215279e43cec5f0" title="Removes the next element in the queue, effectively reducing its size by one. The element removed is t...">queue::pop</a> is called.  <a href="classft_1_1queue.html#ae12e417de9378976ad4389e74002fd5e">More...</a><br /></td></tr>
<tr class="separator:ae12e417de9378976ad4389e74002fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922e9fcf9837132f9b2df398a9604ab4"><td class="memItemLeft" align="right" valign="top">const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#a922e9fcf9837132f9b2df398a9604ab4">front</a> () const</td></tr>
<tr class="memdesc:a922e9fcf9837132f9b2df398a9604ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the next element in the queue. The next element is the "oldest" element in the queue and the same element that is popped out from the queue when <a class="el" href="classft_1_1queue.html#ac3b7cf57b3541f9f4215279e43cec5f0" title="Removes the next element in the queue, effectively reducing its size by one. The element removed is t...">queue::pop</a> is called.  <a href="classft_1_1queue.html#a922e9fcf9837132f9b2df398a9604ab4">More...</a><br /></td></tr>
<tr class="separator:a922e9fcf9837132f9b2df398a9604ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3138989cedfa6b1671687b35c3c4a"><td class="memItemLeft" align="right" valign="top">value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#a77e3138989cedfa6b1671687b35c3c4a">back</a> ()</td></tr>
<tr class="memdesc:a77e3138989cedfa6b1671687b35c3c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the queue. This is the "newest" element in the queue (i.e. the last element pushed into the queue).  <a href="classft_1_1queue.html#a77e3138989cedfa6b1671687b35c3c4a">More...</a><br /></td></tr>
<tr class="separator:a77e3138989cedfa6b1671687b35c3c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440e53f1a7daaa70610a33252b4f9bb8"><td class="memItemLeft" align="right" valign="top">const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#a440e53f1a7daaa70610a33252b4f9bb8">back</a> () const</td></tr>
<tr class="memdesc:a440e53f1a7daaa70610a33252b4f9bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the last element in the queue. This is the "newest" element in the queue (i.e. the last element pushed into the queue).  <a href="classft_1_1queue.html#a440e53f1a7daaa70610a33252b4f9bb8">More...</a><br /></td></tr>
<tr class="separator:a440e53f1a7daaa70610a33252b4f9bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bac32227e1785cce65518595126cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1queue.html#aed8bac32227e1785cce65518595126cf">push</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:aed8bac32227e1785cce65518595126cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the end of the queue, after its current last element. The content of this new element is initialized to val.  <a href="classft_1_1queue.html#aed8bac32227e1785cce65518595126cf">More...</a><br /></td></tr>
<tr class="separator:aed8bac32227e1785cce65518595126cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b7cf57b3541f9f4215279e43cec5f0"><td class="memItemLeft" align="right" valign="top"><a id="ac3b7cf57b3541f9f4215279e43cec5f0" name="ac3b7cf57b3541f9f4215279e43cec5f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop</b> ()</td></tr>
<tr class="memdesc:ac3b7cf57b3541f9f4215279e43cec5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the next element in the queue, effectively reducing its size by one. The element removed is the "oldest" element in the queue whose value can be retrieved by calling member <a class="el" href="classft_1_1queue.html#ae12e417de9378976ad4389e74002fd5e" title="Returns a reference to the next element in the queue. The next element is the &quot;oldest&quot; element in the...">queue::front</a>. <br /></td></tr>
<tr class="separator:ac3b7cf57b3541f9f4215279e43cec5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:accb3356b5256db8925ad01aec919a5f4"><td class="memItemLeft" align="right" valign="top"><a id="accb3356b5256db8925ad01aec919a5f4" name="accb3356b5256db8925ad01aec919a5f4"></a>
container_type&#160;</td><td class="memItemRight" valign="bottom"><b>c</b></td></tr>
<tr class="memdesc:accb3356b5256db8925ad01aec919a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>c</code> is the underlying container. <br /></td></tr>
<tr class="separator:accb3356b5256db8925ad01aec919a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a373e392a51965599d92a22ecef7fdaa4"><td class="memItemLeft" align="right" valign="top"><a id="a373e392a51965599d92a22ecef7fdaa4" name="a373e392a51965599d92a22ecef7fdaa4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classft_1_1queue.html">queue</a>&lt; T, Container &gt; &amp;lhs, const <a class="el" href="classft_1_1queue.html">queue</a>&lt; T, Container &gt; &amp;rhs)</td></tr>
<tr class="separator:a373e392a51965599d92a22ecef7fdaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe192122dbe05eda2b3d6a3e51e280a"><td class="memItemLeft" align="right" valign="top"><a id="a3fe192122dbe05eda2b3d6a3e51e280a" name="a3fe192122dbe05eda2b3d6a3e51e280a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classft_1_1queue.html">queue</a>&lt; T, Container &gt; &amp;lhs, const <a class="el" href="classft_1_1queue.html">queue</a>&lt; T, Container &gt; &amp;rhs)</td></tr>
<tr class="separator:a3fe192122dbe05eda2b3d6a3e51e280a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Container = list&lt;T&gt;&gt;<br />
class ft::queue&lt; T, Container &gt;</div><p >Queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other. Queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front". </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements. </td></tr>
    <tr><td class="paramname">Container</td><td>Type of the internal underlying container object where the elements are stored. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a113a5e468b57e818125de12e98ea93cd" name="a113a5e468b57e818125de12e98ea93cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113a5e468b57e818125de12e98ea93cd">&#9670;&nbsp;</a></span>queue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::queue </td>
          <td>(</td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>ctnr</em> = <code>container_type()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructs a queue container adaptor object. A container adaptor keeps internally a container object as data. This container object is a copy of the ctnr argument passed to the constructor, if any, otherwise it is an empty container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctnr</td><td>Container object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fbe4f3bd15caa14373c17fd5eb372b4" name="a8fbe4f3bd15caa14373c17fd5eb372b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbe4f3bd15caa14373c17fd5eb372b4">&#9670;&nbsp;</a></span>queue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1queue.html">queue</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: Constructs a container with a copy of each of the elements in x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another queue object of the same type (with the same class template arguments T and Container), whose contents are either copied or acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77e3138989cedfa6b1671687b35c3c4a" name="a77e3138989cedfa6b1671687b35c3c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e3138989cedfa6b1671687b35c3c4a">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type &amp; <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the queue. This is the "newest" element in the queue (i.e. the last element pushed into the queue). </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last element in the queue. </dd></dl>

</div>
</div>
<a id="a440e53f1a7daaa70610a33252b4f9bb8" name="a440e53f1a7daaa70610a33252b4f9bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440e53f1a7daaa70610a33252b4f9bb8">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type &amp; <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the last element in the queue. This is the "newest" element in the queue (i.e. the last element pushed into the queue). </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the last element in the queue. </dd></dl>

</div>
</div>
<a id="a81cf7d446c8fb8bce14023e21788893d" name="a81cf7d446c8fb8bce14023e21788893d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cf7d446c8fb8bce14023e21788893d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the queue is empty: i.e. whether its size is zero. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the underlying container's size is 0, false otherwise. </dd></dl>

</div>
</div>
<a id="ae12e417de9378976ad4389e74002fd5e" name="ae12e417de9378976ad4389e74002fd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12e417de9378976ad4389e74002fd5e">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type &amp; <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the next element in the queue. The next element is the "oldest" element in the queue and the same element that is popped out from the queue when <a class="el" href="classft_1_1queue.html#ac3b7cf57b3541f9f4215279e43cec5f0" title="Removes the next element in the queue, effectively reducing its size by one. The element removed is t...">queue::pop</a> is called. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the next element in the queue. </dd></dl>

</div>
</div>
<a id="a922e9fcf9837132f9b2df398a9604ab4" name="a922e9fcf9837132f9b2df398a9604ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922e9fcf9837132f9b2df398a9604ab4">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_type &amp; <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the next element in the queue. The next element is the "oldest" element in the queue and the same element that is popped out from the queue when <a class="el" href="classft_1_1queue.html#ac3b7cf57b3541f9f4215279e43cec5f0" title="Removes the next element in the queue, effectively reducing its size by one. The element removed is t...">queue::pop</a> is called. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the next element in the queue. </dd></dl>

</div>
</div>
<a id="aaca62866c5e9b732ee0c20e742dd1095" name="aaca62866c5e9b732ee0c20e742dd1095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca62866c5e9b732ee0c20e742dd1095">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1queue.html">queue</a> &amp; <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1queue.html">queue</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all the elements from x into the container, changing its size accordingly. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="aed8bac32227e1785cce65518595126cf" name="aed8bac32227e1785cce65518595126cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8bac32227e1785cce65518595126cf">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at the end of the queue, after its current last element. The content of this new element is initialized to val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to which the inserted element is initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf3641432645eb900b2a24227e5a9c7e" name="abf3641432645eb900b2a24227e5a9c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3641432645eb900b2a24227e5a9c7e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container  = list&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1queue.html">ft::queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the underlying container. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>incs/<a class="el" href="queue_8hpp_source.html">queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
