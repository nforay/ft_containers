<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ft_container: ft::vector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ft_container<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ft</b></li><li class="navelem"><a class="el" href="classft_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classft_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ft::vector&lt; T, Alloc &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Vectors are sequence containers representing arrays that can change in size.  
 <a href="classft_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad2cd97067d78f9f6d706bddd8a490a4f"><td class="memItemLeft" align="right" valign="top"><a id="ad2cd97067d78f9f6d706bddd8a490a4f" name="ad2cd97067d78f9f6d706bddd8a490a4f"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ad2cd97067d78f9f6d706bddd8a490a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480dc67bb42fd6f93d04a5b39ebb30fc"><td class="memItemLeft" align="right" valign="top"><a id="a480dc67bb42fd6f93d04a5b39ebb30fc" name="a480dc67bb42fd6f93d04a5b39ebb30fc"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a480dc67bb42fd6f93d04a5b39ebb30fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5578812911bd77d71ee37c1530451ed2"><td class="memItemLeft" align="right" valign="top"><a id="a5578812911bd77d71ee37c1530451ed2" name="a5578812911bd77d71ee37c1530451ed2"></a>
typedef allocator_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a5578812911bd77d71ee37c1530451ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f51cb711c4cb228882efd94a7031b1"><td class="memItemLeft" align="right" valign="top"><a id="ac4f51cb711c4cb228882efd94a7031b1" name="ac4f51cb711c4cb228882efd94a7031b1"></a>
typedef allocator_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:ac4f51cb711c4cb228882efd94a7031b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e23d4cedbdc93bc1cf6b5466f03188"><td class="memItemLeft" align="right" valign="top"><a id="aa4e23d4cedbdc93bc1cf6b5466f03188" name="aa4e23d4cedbdc93bc1cf6b5466f03188"></a>
typedef allocator_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:aa4e23d4cedbdc93bc1cf6b5466f03188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718f973064b2724893bd374115659527"><td class="memItemLeft" align="right" valign="top"><a id="a718f973064b2724893bd374115659527" name="a718f973064b2724893bd374115659527"></a>
typedef allocator_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a718f973064b2724893bd374115659527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6478ed6701a56507e5453622031b17"><td class="memItemLeft" align="right" valign="top"><a id="a2a6478ed6701a56507e5453622031b17" name="a2a6478ed6701a56507e5453622031b17"></a>
typedef <a class="el" href="classft_1_1Vector__iterator.html">Vector_iterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a2a6478ed6701a56507e5453622031b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1042b91185ca8c18335a85073d2c4e0b"><td class="memItemLeft" align="right" valign="top"><a id="a1042b91185ca8c18335a85073d2c4e0b" name="a1042b91185ca8c18335a85073d2c4e0b"></a>
typedef <a class="el" href="classft_1_1Vector__const__iterator.html">Vector_const_iterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a1042b91185ca8c18335a85073d2c4e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c899ee86d87a6a1cd0efabe689e3c2"><td class="memItemLeft" align="right" valign="top"><a id="a97c899ee86d87a6a1cd0efabe689e3c2" name="a97c899ee86d87a6a1cd0efabe689e3c2"></a>
typedef <a class="el" href="classft_1_1Vector__const__reverse__iterator.html">Vector_const_reverse_iterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a97c899ee86d87a6a1cd0efabe689e3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc759f1a608262e737d646f5284a3b"><td class="memItemLeft" align="right" valign="top"><a id="af9cc759f1a608262e737d646f5284a3b" name="af9cc759f1a608262e737d646f5284a3b"></a>
typedef <a class="el" href="classft_1_1Vector__reverse__iterator.html">Vector_reverse_iterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:af9cc759f1a608262e737d646f5284a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8573327959f0d0b57987f49da14a0a66"><td class="memItemLeft" align="right" valign="top"><a id="a8573327959f0d0b57987f49da14a0a66" name="a8573327959f0d0b57987f49da14a0a66"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a8573327959f0d0b57987f49da14a0a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9dc79f744edfce74f6616ab00e97ea"><td class="memItemLeft" align="right" valign="top"><a id="a0d9dc79f744edfce74f6616ab00e97ea" name="a0d9dc79f744edfce74f6616ab00e97ea"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a0d9dc79f744edfce74f6616ab00e97ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a303838602702b8d37428d14aac0f18a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a303838602702b8d37428d14aac0f18a2">vector</a> (const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a303838602702b8d37428d14aac0f18a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty container constructor (default constructor): Constructs an empty container, with no elements.  <a href="classft_1_1vector.html#a303838602702b8d37428d14aac0f18a2">More...</a><br /></td></tr>
<tr class="separator:a303838602702b8d37428d14aac0f18a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad33782789ab70cd93011e8f680fbc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a1ad33782789ab70cd93011e8f680fbc1">vector</a> (size_type n, const value_type &amp;val=value_type(), const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a1ad33782789ab70cd93011e8f680fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill constructor: Constructs a container with n elements. Each element is a copy of val.  <a href="classft_1_1vector.html#a1ad33782789ab70cd93011e8f680fbc1">More...</a><br /></td></tr>
<tr class="separator:a1ad33782789ab70cd93011e8f680fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a0d7d2149ff73c6db334e5b638dd31"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a68a0d7d2149ff73c6db334e5b638dd31"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a68a0d7d2149ff73c6db334e5b638dd31">vector</a> (typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type first, InputIterator last, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a68a0d7d2149ff73c6db334e5b638dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">range constructor: Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range, in the same order.  <a href="classft_1_1vector.html#a68a0d7d2149ff73c6db334e5b638dd31">More...</a><br /></td></tr>
<tr class="separator:a68a0d7d2149ff73c6db334e5b638dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890a405d80f9ec770bffa2bee6aabc02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a890a405d80f9ec770bffa2bee6aabc02">vector</a> (const <a class="el" href="classft_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:a890a405d80f9ec770bffa2bee6aabc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor: Constructs a container with a copy of each of the elements in x, in the same order.  <a href="classft_1_1vector.html#a890a405d80f9ec770bffa2bee6aabc02">More...</a><br /></td></tr>
<tr class="separator:a890a405d80f9ec770bffa2bee6aabc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52b3f715979c31463fed0871637fbd3"><td class="memItemLeft" align="right" valign="top"><a id="ae52b3f715979c31463fed0871637fbd3" name="ae52b3f715979c31463fed0871637fbd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~vector</b> ()</td></tr>
<tr class="memdesc:ae52b3f715979c31463fed0871637fbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector destructor: Destroys the container object. This destroys all container elements, and deallocates all the storage capacity allocated by the vector using its allocator. <br /></td></tr>
<tr class="separator:ae52b3f715979c31463fed0871637fbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3905a048b66b77e6140f33704c3f03e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ad3905a048b66b77e6140f33704c3f03e">operator=</a> (const <a class="el" href="classft_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:ad3905a048b66b77e6140f33704c3f03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. The container preserves its current allocator, which is used to allocate storage in case of reallocation.  <a href="classft_1_1vector.html#ad3905a048b66b77e6140f33704c3f03e">More...</a><br /></td></tr>
<tr class="separator:ad3905a048b66b77e6140f33704c3f03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e54b404a6173fb59e5601d2c842aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a676e54b404a6173fb59e5601d2c842aa">begin</a> ()</td></tr>
<tr class="memdesc:a676e54b404a6173fb59e5601d2c842aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first element in the vector.  <a href="classft_1_1vector.html#a676e54b404a6173fb59e5601d2c842aa">More...</a><br /></td></tr>
<tr class="separator:a676e54b404a6173fb59e5601d2c842aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1afbee982ef6e3882f86c8e46fb6dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ad1afbee982ef6e3882f86c8e46fb6dfb">begin</a> () const</td></tr>
<tr class="memdesc:ad1afbee982ef6e3882f86c8e46fb6dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator pointing to the first element in the vector.  <a href="classft_1_1vector.html#ad1afbee982ef6e3882f86c8e46fb6dfb">More...</a><br /></td></tr>
<tr class="separator:ad1afbee982ef6e3882f86c8e46fb6dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f3b60e721af77263c5b7d5cfed2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#af72f3b60e721af77263c5b7d5cfed2a2">end</a> ()</td></tr>
<tr class="memdesc:af72f3b60e721af77263c5b7d5cfed2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator referring to the past-the-end element in the vector container. The past-the-end element is the theoretical element that would follow the last element in the vector. It does not point to any element, and thus shall not be dereferenced.  <a href="classft_1_1vector.html#af72f3b60e721af77263c5b7d5cfed2a2">More...</a><br /></td></tr>
<tr class="separator:af72f3b60e721af77263c5b7d5cfed2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd904b8a6519baac8fa855d7ad1bfb6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#acd904b8a6519baac8fa855d7ad1bfb6c">end</a> () const</td></tr>
<tr class="memdesc:acd904b8a6519baac8fa855d7ad1bfb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator referring to the past-the-end element in the vector container. The past-the-end element is the theoretical element that would follow the last element in the vector. It does not point to any element, and thus shall not be dereferenced.  <a href="classft_1_1vector.html#acd904b8a6519baac8fa855d7ad1bfb6c">More...</a><br /></td></tr>
<tr class="separator:acd904b8a6519baac8fa855d7ad1bfb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11d0995f184a895e8540da785e9a1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ae11d0995f184a895e8540da785e9a1de">rbegin</a> ()</td></tr>
<tr class="memdesc:ae11d0995f184a895e8540da785e9a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end.  <a href="classft_1_1vector.html#ae11d0995f184a895e8540da785e9a1de">More...</a><br /></td></tr>
<tr class="separator:ae11d0995f184a895e8540da785e9a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9170d6e61d85a5a7b1a81fecc54bb198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a9170d6e61d85a5a7b1a81fecc54bb198">rbegin</a> () const</td></tr>
<tr class="memdesc:a9170d6e61d85a5a7b1a81fecc54bb198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end.  <a href="classft_1_1vector.html#a9170d6e61d85a5a7b1a81fecc54bb198">More...</a><br /></td></tr>
<tr class="separator:a9170d6e61d85a5a7b1a81fecc54bb198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b010d6fdab1cf83ea6dbad598a2078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a43b010d6fdab1cf83ea6dbad598a2078">rend</a> ()</td></tr>
<tr class="memdesc:a43b010d6fdab1cf83ea6dbad598a2078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator pointing to the theoretical element preceding the first element in the vector (which is considered its reverse end). The range between <a class="el" href="classft_1_1vector.html#ae11d0995f184a895e8540da785e9a1de" title="Returns a reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning)....">vector::rbegin</a> and <a class="el" href="classft_1_1vector.html#a43b010d6fdab1cf83ea6dbad598a2078" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the vec...">vector::rend</a> contains all the elements of the vector (in reverse order).  <a href="classft_1_1vector.html#a43b010d6fdab1cf83ea6dbad598a2078">More...</a><br /></td></tr>
<tr class="separator:a43b010d6fdab1cf83ea6dbad598a2078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4feeb9416ff1e5cdc6fa1912d13b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#abf4feeb9416ff1e5cdc6fa1912d13b3d">rend</a> () const</td></tr>
<tr class="memdesc:abf4feeb9416ff1e5cdc6fa1912d13b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator pointing to the theoretical element preceding the first element in the vector (which is considered its reverse end). The range between <a class="el" href="classft_1_1vector.html#ae11d0995f184a895e8540da785e9a1de" title="Returns a reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning)....">vector::rbegin</a> and <a class="el" href="classft_1_1vector.html#a43b010d6fdab1cf83ea6dbad598a2078" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the vec...">vector::rend</a> contains all the elements of the vector (in reverse order).  <a href="classft_1_1vector.html#abf4feeb9416ff1e5cdc6fa1912d13b3d">More...</a><br /></td></tr>
<tr class="separator:abf4feeb9416ff1e5cdc6fa1912d13b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490bdf708cfc1da512f5d101dc5ddefa"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a490bdf708cfc1da512f5d101dc5ddefa">size</a> () const</td></tr>
<tr class="memdesc:a490bdf708cfc1da512f5d101dc5ddefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector. This is the number of actual objects held in the vector, which is not necessarily equal to its storage capacity.  <a href="classft_1_1vector.html#a490bdf708cfc1da512f5d101dc5ddefa">More...</a><br /></td></tr>
<tr class="separator:a490bdf708cfc1da512f5d101dc5ddefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbf110c7765bb1820bdae62fbd0bcb3"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#aebbf110c7765bb1820bdae62fbd0bcb3">max_size</a> () const</td></tr>
<tr class="memdesc:aebbf110c7765bb1820bdae62fbd0bcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements that the vector can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached.  <a href="classft_1_1vector.html#aebbf110c7765bb1820bdae62fbd0bcb3">More...</a><br /></td></tr>
<tr class="separator:aebbf110c7765bb1820bdae62fbd0bcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf24745c9d0fbb048e6d87dca30457e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a2bf24745c9d0fbb048e6d87dca30457e">resize</a> (size_type n, value_type val=value_type())</td></tr>
<tr class="memdesc:a2bf24745c9d0fbb048e6d87dca30457e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place.  <a href="classft_1_1vector.html#a2bf24745c9d0fbb048e6d87dca30457e">More...</a><br /></td></tr>
<tr class="separator:a2bf24745c9d0fbb048e6d87dca30457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93048c1e7da37249ac00a5cae6de5b5"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#aa93048c1e7da37249ac00a5cae6de5b5">capacity</a> () const</td></tr>
<tr class="memdesc:aa93048c1e7da37249ac00a5cae6de5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion.  <a href="classft_1_1vector.html#aa93048c1e7da37249ac00a5cae6de5b5">More...</a><br /></td></tr>
<tr class="separator:aa93048c1e7da37249ac00a5cae6de5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79b4b7c92c41053624cb34b1e3a3413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ad79b4b7c92c41053624cb34b1e3a3413">empty</a> () const</td></tr>
<tr class="memdesc:ad79b4b7c92c41053624cb34b1e3a3413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the vector is empty (i.e. whether its size is 0).  <a href="classft_1_1vector.html#ad79b4b7c92c41053624cb34b1e3a3413">More...</a><br /></td></tr>
<tr class="separator:ad79b4b7c92c41053624cb34b1e3a3413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a861adeac518ae463849747367ead68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a4a861adeac518ae463849747367ead68">reserve</a> (size_type n)</td></tr>
<tr class="memdesc:a4a861adeac518ae463849747367ead68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements.  <a href="classft_1_1vector.html#a4a861adeac518ae463849747367ead68">More...</a><br /></td></tr>
<tr class="separator:a4a861adeac518ae463849747367ead68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff237f296e6d5c2d28799d39611ba7"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a0cff237f296e6d5c2d28799d39611ba7">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a0cff237f296e6d5c2d28799d39611ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position n in the vector container.  <a href="classft_1_1vector.html#a0cff237f296e6d5c2d28799d39611ba7">More...</a><br /></td></tr>
<tr class="separator:a0cff237f296e6d5c2d28799d39611ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb3e27715d302411c32bd943e33ce3"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ac1fb3e27715d302411c32bd943e33ce3">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ac1fb3e27715d302411c32bd943e33ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference to the element at position n in the vector container.  <a href="classft_1_1vector.html#ac1fb3e27715d302411c32bd943e33ce3">More...</a><br /></td></tr>
<tr class="separator:ac1fb3e27715d302411c32bd943e33ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68d8f3525720cd84ba18449b1947019"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ae68d8f3525720cd84ba18449b1947019">at</a> (size_type n)</td></tr>
<tr class="memdesc:ae68d8f3525720cd84ba18449b1947019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position n in the vector. The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if n is greater than, or equal to, its size). This is in contrast with member operator[], that does not check against bounds.  <a href="classft_1_1vector.html#ae68d8f3525720cd84ba18449b1947019">More...</a><br /></td></tr>
<tr class="separator:ae68d8f3525720cd84ba18449b1947019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905bea2d6d0c3aa961c5cf71b1911b34"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a905bea2d6d0c3aa961c5cf71b1911b34">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a905bea2d6d0c3aa961c5cf71b1911b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference to the element at position n in the vector. The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if n is greater than, or equal to, its size). This is in contrast with member operator[], that does not check against bounds.  <a href="classft_1_1vector.html#a905bea2d6d0c3aa961c5cf71b1911b34">More...</a><br /></td></tr>
<tr class="separator:a905bea2d6d0c3aa961c5cf71b1911b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76566047926216856dcedd8cac9575b"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#af76566047926216856dcedd8cac9575b">front</a> ()</td></tr>
<tr class="memdesc:af76566047926216856dcedd8cac9575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#a676e54b404a6173fb59e5601d2c842aa" title="Returns an iterator pointing to the first element in the vector.">vector::begin</a>, which returns an iterator to this same element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior.  <a href="classft_1_1vector.html#af76566047926216856dcedd8cac9575b">More...</a><br /></td></tr>
<tr class="separator:af76566047926216856dcedd8cac9575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7fe427c4e4183297bcefe0321098c2"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a1c7fe427c4e4183297bcefe0321098c2">front</a> () const</td></tr>
<tr class="memdesc:a1c7fe427c4e4183297bcefe0321098c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference to the first element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#a676e54b404a6173fb59e5601d2c842aa" title="Returns an iterator pointing to the first element in the vector.">vector::begin</a>, which returns an iterator to this same element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior.  <a href="classft_1_1vector.html#a1c7fe427c4e4183297bcefe0321098c2">More...</a><br /></td></tr>
<tr class="separator:a1c7fe427c4e4183297bcefe0321098c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b952cb848f0b9467a0d68b1c216c6e"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#ab8b952cb848f0b9467a0d68b1c216c6e">back</a> ()</td></tr>
<tr class="memdesc:ab8b952cb848f0b9467a0d68b1c216c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#af72f3b60e721af77263c5b7d5cfed2a2" title="Returns an iterator referring to the past-the-end element in the vector container....">vector::end</a>, which returns an iterator just past this element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior.  <a href="classft_1_1vector.html#ab8b952cb848f0b9467a0d68b1c216c6e">More...</a><br /></td></tr>
<tr class="separator:ab8b952cb848f0b9467a0d68b1c216c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500860a3ff9442be90caa1a232046475"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a500860a3ff9442be90caa1a232046475">back</a> () const</td></tr>
<tr class="memdesc:a500860a3ff9442be90caa1a232046475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reference to the last element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#af72f3b60e721af77263c5b7d5cfed2a2" title="Returns an iterator referring to the past-the-end element in the vector container....">vector::end</a>, which returns an iterator just past this element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior.  <a href="classft_1_1vector.html#a500860a3ff9442be90caa1a232046475">More...</a><br /></td></tr>
<tr class="separator:a500860a3ff9442be90caa1a232046475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fc94df5373899f0ca25d043fe6ff29"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a49fc94df5373899f0ca25d043fe6ff29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a49fc94df5373899f0ca25d043fe6ff29">assign</a> (typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type first, InputIterator last)</td></tr>
<tr class="memdesc:a49fc94df5373899f0ca25d043fe6ff29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly. Any elements held in the container before the call are destroyed and replaced by newly constructed elements (no assignments of elements take place). The new contents are elements constructed from each of the elements in the range between first and last, in the same order.  <a href="classft_1_1vector.html#a49fc94df5373899f0ca25d043fe6ff29">More...</a><br /></td></tr>
<tr class="separator:a49fc94df5373899f0ca25d043fe6ff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea70f6934f2a910104661febc4367877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#aea70f6934f2a910104661febc4367877">assign</a> (size_type n, const value_type &amp;val)</td></tr>
<tr class="memdesc:aea70f6934f2a910104661febc4367877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly. Any elements held in the container before the call are destroyed and replaced by newly constructed elements (no assignments of elements take place). The new contents are n elements, each initialized to a copy of val.  <a href="classft_1_1vector.html#aea70f6934f2a910104661febc4367877">More...</a><br /></td></tr>
<tr class="separator:aea70f6934f2a910104661febc4367877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f04104b289398df0fc6e14970882e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a4f04104b289398df0fc6e14970882e78">push_back</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a4f04104b289398df0fc6e14970882e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the vector, after its current last element. The content of val is copied (or moved) to the new element.  <a href="classft_1_1vector.html#a4f04104b289398df0fc6e14970882e78">More...</a><br /></td></tr>
<tr class="separator:a4f04104b289398df0fc6e14970882e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a67c116948d3292c83678f257de0939"><td class="memItemLeft" align="right" valign="top"><a id="a5a67c116948d3292c83678f257de0939" name="a5a67c116948d3292c83678f257de0939"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="memdesc:a5a67c116948d3292c83678f257de0939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the vector, effectively reducing the container size by one. This destroys the removed element. <br /></td></tr>
<tr class="separator:a5a67c116948d3292c83678f257de0939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9167ffcce6a2b93cb39d804b7eba51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a4f9167ffcce6a2b93cb39d804b7eba51">insert</a> (<a class="el" href="classft_1_1Vector__iterator.html">iterator</a> position, const value_type &amp;val)</td></tr>
<tr class="memdesc:a4f9167ffcce6a2b93cb39d804b7eba51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector is extended by inserting a new element before the element at the specified position, effectively increasing the container size by 1.  <a href="classft_1_1vector.html#a4f9167ffcce6a2b93cb39d804b7eba51">More...</a><br /></td></tr>
<tr class="separator:a4f9167ffcce6a2b93cb39d804b7eba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30006d85199d2a1307fe4cb61c3464e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a30006d85199d2a1307fe4cb61c3464e1">insert</a> (<a class="el" href="classft_1_1Vector__iterator.html">iterator</a> position, size_type n, const value_type &amp;val)</td></tr>
<tr class="memdesc:a30006d85199d2a1307fe4cb61c3464e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector is extended by inserting new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted.  <a href="classft_1_1vector.html#a30006d85199d2a1307fe4cb61c3464e1">More...</a><br /></td></tr>
<tr class="separator:a30006d85199d2a1307fe4cb61c3464e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c22be71f51ec15aa1f147dba83b3217"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a9c22be71f51ec15aa1f147dba83b3217"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a9c22be71f51ec15aa1f147dba83b3217">insert</a> (<a class="el" href="classft_1_1Vector__iterator.html">iterator</a> position, typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt;::is_integer, InputIterator &gt; ::type first, InputIterator last)</td></tr>
<tr class="memdesc:a9c22be71f51ec15aa1f147dba83b3217"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector is extended by inserting new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted.  <a href="classft_1_1vector.html#a9c22be71f51ec15aa1f147dba83b3217">More...</a><br /></td></tr>
<tr class="separator:a9c22be71f51ec15aa1f147dba83b3217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8176999c0512ad844571b58dc70e87ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a8176999c0512ad844571b58dc70e87ac">erase</a> (<a class="el" href="classft_1_1Vector__iterator.html">iterator</a> position)</td></tr>
<tr class="memdesc:a8176999c0512ad844571b58dc70e87ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single element from the vector. This effectively reduces the container size by 1 and destroy the element.  <a href="classft_1_1vector.html#a8176999c0512ad844571b58dc70e87ac">More...</a><br /></td></tr>
<tr class="separator:a8176999c0512ad844571b58dc70e87ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b60e9431e3dcb0df42f721ae869a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a23b60e9431e3dcb0df42f721ae869a45">erase</a> (<a class="el" href="classft_1_1Vector__iterator.html">iterator</a> first, <a class="el" href="classft_1_1Vector__iterator.html">iterator</a> last)</td></tr>
<tr class="memdesc:a23b60e9431e3dcb0df42f721ae869a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes from the vector a range of elements ([first,last)). This effectively reduces the container size by the number of elements removed, which are destroyed.  <a href="classft_1_1vector.html#a23b60e9431e3dcb0df42f721ae869a45">More...</a><br /></td></tr>
<tr class="separator:a23b60e9431e3dcb0df42f721ae869a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec29996956240c0d4244e996dee48259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#aec29996956240c0d4244e996dee48259">swap</a> (<a class="el" href="classft_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:aec29996956240c0d4244e996dee48259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the content of the container by the content of x, which is another vector object of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in x before the call, and the elements of x are those which were in this. All iterators, references and pointers remain valid for the swapped objects.  <a href="classft_1_1vector.html#aec29996956240c0d4244e996dee48259">More...</a><br /></td></tr>
<tr class="separator:aec29996956240c0d4244e996dee48259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80556485b9ac2af1270e9c1b411585f2"><td class="memItemLeft" align="right" valign="top"><a id="a80556485b9ac2af1270e9c1b411585f2" name="a80556485b9ac2af1270e9c1b411585f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a80556485b9ac2af1270e9c1b411585f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the vector (which are destroyed), leaving the container with a size of 0. <br /></td></tr>
<tr class="separator:a80556485b9ac2af1270e9c1b411585f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f14230194b6514171b8fb023209f8cf"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classft_1_1vector.html#a3f14230194b6514171b8fb023209f8cf">get_allocator</a> () const</td></tr>
<tr class="memdesc:a3f14230194b6514171b8fb023209f8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator object associated with the vector.  <a href="classft_1_1vector.html#a3f14230194b6514171b8fb023209f8cf">More...</a><br /></td></tr>
<tr class="separator:a3f14230194b6514171b8fb023209f8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class ft::vector&lt; T, Alloc &gt;</div><p >Vectors are sequence containers representing arrays that can change in size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of the allocator object used to define the storage allocation model. By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a303838602702b8d37428d14aac0f18a2" name="a303838602702b8d37428d14aac0f18a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303838602702b8d37428d14aac0f18a2">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>empty container constructor (default constructor): Constructs an empty container, with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ad33782789ab70cd93011e8f680fbc1" name="a1ad33782789ab70cd93011e8f680fbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad33782789ab70cd93011e8f680fbc1">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>value_type()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill constructor: Constructs a container with n elements. Each element is a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Initial container size (i.e., the number of elements in the container at construction). </td></tr>
    <tr><td class="paramname">val</td><td>Value to fill the container with. Each of the n elements in the container will be initialized to a copy of this value. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a0d7d2149ff73c6db334e5b638dd31" name="a68a0d7d2149ff73c6db334e5b638dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a0d7d2149ff73c6db334e5b638dd31">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>range constructor: Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Input iterators to the initial and final positions in a range. The range used is [first,last), which includes all the elements between first and last, including the element pointed by first but not the element pointed by last. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator object. The container keeps and uses an internal copy of this allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a890a405d80f9ec770bffa2bee6aabc02" name="a890a405d80f9ec770bffa2bee6aabc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890a405d80f9ec770bffa2bee6aabc02">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor: Constructs a container with a copy of each of the elements in x, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another vector object of the same type (with the same class template arguments T and Alloc), whose contents are either copied or acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aea70f6934f2a910104661febc4367877" name="aea70f6934f2a910104661febc4367877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea70f6934f2a910104661febc4367877">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly. Any elements held in the container before the call are destroyed and replaced by newly constructed elements (no assignments of elements take place). The new contents are n elements, each initialized to a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New size for the container. </td></tr>
    <tr><td class="paramname">val</td><td>Value to fill the container with. Each of the n elements in the container will be initialized to a copy of this value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49fc94df5373899f0ca25d043fe6ff29" name="a49fc94df5373899f0ca25d043fe6ff29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fc94df5373899f0ca25d043fe6ff29">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt; ::is_integer, InputIterator &gt;::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly. Any elements held in the container before the call are destroyed and replaced by newly constructed elements (no assignments of elements take place). The new contents are elements constructed from each of the elements in the range between first and last, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Input iterators to the initial and final positions in a sequence. The range used is [first,last), which includes all the elements between first and last, including the element pointed by first but not the element pointed by last. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae68d8f3525720cd84ba18449b1947019" name="ae68d8f3525720cd84ba18449b1947019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68d8f3525720cd84ba18449b1947019">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at position n in the vector. The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if n is greater than, or equal to, its size). This is in contrast with member operator[], that does not check against bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Position of an element in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified position in the container. </dd></dl>

</div>
</div>
<a id="a905bea2d6d0c3aa961c5cf71b1911b34" name="a905bea2d6d0c3aa961c5cf71b1911b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905bea2d6d0c3aa961c5cf71b1911b34">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference to the element at position n in the vector. The function automatically checks whether n is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if n is greater than, or equal to, its size). This is in contrast with member operator[], that does not check against bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Position of an element in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified position in the container. </dd></dl>

</div>
</div>
<a id="ab8b952cb848f0b9467a0d68b1c216c6e" name="ab8b952cb848f0b9467a0d68b1c216c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b952cb848f0b9467a0d68b1c216c6e">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#af72f3b60e721af77263c5b7d5cfed2a2" title="Returns an iterator referring to the past-the-end element in the vector container....">vector::end</a>, which returns an iterator just past this element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a500860a3ff9442be90caa1a232046475" name="a500860a3ff9442be90caa1a232046475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500860a3ff9442be90caa1a232046475">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference to the last element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#af72f3b60e721af77263c5b7d5cfed2a2" title="Returns an iterator referring to the past-the-end element in the vector container....">vector::end</a>, which returns an iterator just past this element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reference to the last element in the vector. </dd></dl>

</div>
</div>
<a id="a676e54b404a6173fb59e5601d2c842aa" name="a676e54b404a6173fb59e5601d2c842aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676e54b404a6173fb59e5601d2c842aa">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first element in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the sequence container. If the container is empty, the returned iterator value shall not be dereferenced. </dd></dl>

</div>
</div>
<a id="ad1afbee982ef6e3882f86c8e46fb6dfb" name="ad1afbee982ef6e3882f86c8e46fb6dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1afbee982ef6e3882f86c8e46fb6dfb">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator pointing to the first element in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>An const_iterator to the beginning of the sequence container. If the container is empty, the returned iterator value shall not be dereferenced. </dd></dl>

</div>
</div>
<a id="aa93048c1e7da37249ac00a5cae6de5b5" name="aa93048c1e7da37249ac00a5cae6de5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93048c1e7da37249ac00a5cae6de5b5">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the storage space currently allocated for the vector, expressed in terms of elements. This capacity is not necessarily equal to the vector size. It can be equal or greater, with the extra space allowing to accommodate for growth without the need to reallocate on each insertion. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the currently allocated storage capacity in the vector, measured in terms of the number elements it can hold. </dd></dl>

</div>
</div>
<a id="ad79b4b7c92c41053624cb34b1e3a3413" name="ad79b4b7c92c41053624cb34b1e3a3413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79b4b7c92c41053624cb34b1e3a3413">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the vector is empty (i.e. whether its size is 0). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container size is 0, false otherwise. </dd></dl>

</div>
</div>
<a id="af72f3b60e721af77263c5b7d5cfed2a2" name="af72f3b60e721af77263c5b7d5cfed2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72f3b60e721af77263c5b7d5cfed2a2">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator referring to the past-the-end element in the vector container. The past-the-end element is the theoretical element that would follow the last element in the vector. It does not point to any element, and thus shall not be dereferenced. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an iterator referring to the past-the-end element in the vector container. </dd></dl>

</div>
</div>
<a id="acd904b8a6519baac8fa855d7ad1bfb6c" name="acd904b8a6519baac8fa855d7ad1bfb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd904b8a6519baac8fa855d7ad1bfb6c">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__const__iterator.html">const_iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator referring to the past-the-end element in the vector container. The past-the-end element is the theoretical element that would follow the last element in the vector. It does not point to any element, and thus shall not be dereferenced. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a const_iterator referring to the past-the-end element in the vector container. </dd></dl>

</div>
</div>
<a id="a23b60e9431e3dcb0df42f721ae869a45" name="a23b60e9431e3dcb0df42f721ae869a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b60e9431e3dcb0df42f721ae869a45">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes from the vector a range of elements ([first,last)). This effectively reduces the container size by the number of elements removed, which are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Iterators specifying a range within the vector] to be removed: [first,last). i.e., the range includes all the elements between first and last, including the element pointed by first but not the one pointed by last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="a8176999c0512ad844571b58dc70e87ac" name="a8176999c0512ad844571b58dc70e87ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8176999c0512ad844571b58dc70e87ac">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single element from the vector. This effectively reduces the container size by 1 and destroy the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Iterator pointing to a single element to be removed from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element that followed the last element erased by the function call. This is the container end if the operation erased the last element in the sequence. </dd></dl>

</div>
</div>
<a id="af76566047926216856dcedd8cac9575b" name="af76566047926216856dcedd8cac9575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76566047926216856dcedd8cac9575b">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#a676e54b404a6173fb59e5601d2c842aa" title="Returns an iterator pointing to the first element in the vector.">vector::begin</a>, which returns an iterator to this same element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first element in the vector container. </dd></dl>

</div>
</div>
<a id="a1c7fe427c4e4183297bcefe0321098c2" name="a1c7fe427c4e4183297bcefe0321098c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7fe427c4e4183297bcefe0321098c2">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference to the first element in the vector. Unlike member <a class="el" href="classft_1_1vector.html#a676e54b404a6173fb59e5601d2c842aa" title="Returns an iterator pointing to the first element in the vector.">vector::begin</a>, which returns an iterator to this same element, this function returns a direct reference. Calling this function on an empty container causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reference to the first element in the vector container. </dd></dl>

</div>
</div>
<a id="a3f14230194b6514171b8fb023209f8cf" name="a3f14230194b6514171b8fb023209f8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f14230194b6514171b8fb023209f8cf">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the allocator object associated with the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The allocator. </dd></dl>

</div>
</div>
<a id="a4f9167ffcce6a2b93cb39d804b7eba51" name="a4f9167ffcce6a2b93cb39d804b7eba51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9167ffcce6a2b93cb39d804b7eba51">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vector is extended by inserting a new element before the element at the specified position, effectively increasing the container size by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the vector where the new elements are inserted. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the first of the newly inserted elements. </dd></dl>

</div>
</div>
<a id="a30006d85199d2a1307fe4cb61c3464e1" name="a30006d85199d2a1307fe4cb61c3464e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30006d85199d2a1307fe4cb61c3464e1">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vector is extended by inserting new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the vector where the new elements are inserted. </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to insert. Each element is initialized to a copy of val. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be copied (or moved) to the inserted elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c22be71f51ec15aa1f147dba83b3217" name="a9c22be71f51ec15aa1f147dba83b3217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c22be71f51ec15aa1f147dba83b3217">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1Vector__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structft_1_1enable__if.html">ft::enable_if</a>&lt;!std::numeric_limits&lt; InputIterator &gt;::is_integer, InputIterator &gt; ::type&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vector is extended by inserting new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position in the vector where the new elements are inserted. </td></tr>
    <tr><td class="paramname">first,last</td><td>Iterators specifying a range of elements. Copies of the elements in the range [first,last) are inserted at position (in the same order). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebbf110c7765bb1820bdae62fbd0bcb3" name="aebbf110c7765bb1820bdae62fbd0bcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbf110c7765bb1820bdae62fbd0bcb3">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements that the vector can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements a vector container can hold as content. </dd></dl>

</div>
</div>
<a id="ad3905a048b66b77e6140f33704c3f03e" name="ad3905a048b66b77e6140f33704c3f03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3905a048b66b77e6140f33704c3f03e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1vector.html">vector</a> &amp; <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classft_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. The container preserves its current allocator, which is used to allocate storage in case of reallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A vector object of the same type (i.e., with the same template parameters, T and Alloc). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cff237f296e6d5c2d28799d39611ba7" name="a0cff237f296e6d5c2d28799d39611ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cff237f296e6d5c2d28799d39611ba7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at position n in the vector container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Position of an element in the container. Notice that the first element has a position of 0 (not 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified position in the vector. </dd></dl>

</div>
</div>
<a id="ac1fb3e27715d302411c32bd943e33ce3" name="ac1fb3e27715d302411c32bd943e33ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fb3e27715d302411c32bd943e33ce3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reference to the element at position n in the vector container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Position of an element in the container. Notice that the first element has a position of 0 (not 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified position in the vector. </dd></dl>

</div>
</div>
<a id="a4f04104b289398df0fc6e14970882e78" name="a4f04104b289398df0fc6e14970882e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f04104b289398df0fc6e14970882e78">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new element at the end of the vector, after its current last element. The content of val is copied (or moved) to the new element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to be copied (or moved) to the new element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae11d0995f184a895e8540da785e9a1de" name="ae11d0995f184a895e8540da785e9a1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11d0995f184a895e8540da785e9a1de">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__reverse__iterator.html">reverse_iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end. </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse_iterator to the reverse beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a9170d6e61d85a5a7b1a81fecc54bb198" name="a9170d6e61d85a5a7b1a81fecc54bb198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9170d6e61d85a5a7b1a81fecc54bb198">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning). Reverse iterators iterate backwards: increasing them moves them towards the beginning of the container. rbegin points to the element right before the one that would be pointed to by member end. </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reverse_iterator to the reverse beginning of the sequence container. </dd></dl>

</div>
</div>
<a id="a43b010d6fdab1cf83ea6dbad598a2078" name="a43b010d6fdab1cf83ea6dbad598a2078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b010d6fdab1cf83ea6dbad598a2078">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__reverse__iterator.html">reverse_iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator pointing to the theoretical element preceding the first element in the vector (which is considered its reverse end). The range between <a class="el" href="classft_1_1vector.html#ae11d0995f184a895e8540da785e9a1de" title="Returns a reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning)....">vector::rbegin</a> and <a class="el" href="classft_1_1vector.html#a43b010d6fdab1cf83ea6dbad598a2078" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the vec...">vector::rend</a> contains all the elements of the vector (in reverse order). </p>
<dl class="section return"><dt>Returns</dt><dd>A reverse iterator to the reverse end of the sequence container. </dd></dl>

</div>
</div>
<a id="abf4feeb9416ff1e5cdc6fa1912d13b3d" name="abf4feeb9416ff1e5cdc6fa1912d13b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4feeb9416ff1e5cdc6fa1912d13b3d">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classft_1_1Vector__const__reverse__iterator.html">const_reverse_iterator</a> <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator pointing to the theoretical element preceding the first element in the vector (which is considered its reverse end). The range between <a class="el" href="classft_1_1vector.html#ae11d0995f184a895e8540da785e9a1de" title="Returns a reverse_iterator pointing to the last element in the vector (i.e., its reverse beginning)....">vector::rbegin</a> and <a class="el" href="classft_1_1vector.html#a43b010d6fdab1cf83ea6dbad598a2078" title="Returns a reverse iterator pointing to the theoretical element preceding the first element in the vec...">vector::rend</a> contains all the elements of the vector (in reverse order). </p>
<dl class="section return"><dt>Returns</dt><dd>A const_reverse_iterator to the reverse end of the sequence container. </dd></dl>

</div>
</div>
<a id="a4a861adeac518ae463849747367ead68" name="a4a861adeac518ae463849747367ead68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a861adeac518ae463849747367ead68">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Minimum capacity for the vector. Note that the resulting vector capacity may be equal or greater than n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the size requested is greater than the maximum size (<a class="el" href="classft_1_1vector.html#aebbf110c7765bb1820bdae62fbd0bcb3" title="Returns the maximum number of elements that the vector can hold. This is the maximum potential size t...">vector::max_size</a>), a length_error exception is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bf24745c9d0fbb048e6d87dca30457e" name="a2bf24745c9d0fbb048e6d87dca30457e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf24745c9d0fbb048e6d87dca30457e">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em> = <code>value_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New container size, expressed in number of elements. </td></tr>
    <tr><td class="paramname">val</td><td>Object whose content is copied to the added elements in case that n is greater than the current container size. If not specified, the default constructor is used instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a490bdf708cfc1da512f5d101dc5ddefa" name="a490bdf708cfc1da512f5d101dc5ddefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490bdf708cfc1da512f5d101dc5ddefa">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. This is the number of actual objects held in the vector, which is not necessarily equal to its storage capacity. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

</div>
</div>
<a id="aec29996956240c0d4244e996dee48259" name="aec29996956240c0d4244e996dee48259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec29996956240c0d4244e996dee48259">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classft_1_1vector.html">ft::vector</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classft_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the content of the container by the content of x, which is another vector object of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in x before the call, and the elements of x are those which were in this. All iterators, references and pointers remain valid for the swapped objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Another vector container of the same type (i.e., instantiated with the same template parameters, T and Alloc) whose content is swapped with that of this container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>incs/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
